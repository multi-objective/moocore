
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "auto_examples/plot_metrics.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        :ref:`Go to the end <sphx_glr_download_auto_examples_plot_metrics.py>`
        to download the full example code.

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_auto_examples_plot_metrics.py:

Computing Multi-Objective Quality Metrics
=========================================

Several examples of computing multi-objective unary quality metrics.

.. GENERATED FROM PYTHON SOURCE LINES 7-11

.. code-block:: Python


    import numpy as np
    import moocore








.. GENERATED FROM PYTHON SOURCE LINES 12-17

Comparing two multi-objective datasets using unary quality metrics
------------------------------------------------------------------

First, read the datasets.


.. GENERATED FROM PYTHON SOURCE LINES 17-26

.. code-block:: Python


    spherical = moocore.get_dataset("spherical-250-10-3d.txt.xz")
    uniform = moocore.get_dataset("uniform-250-10-3d.txt.xz")

    spherical_objs = spherical[:, :-1]
    spherical_sets = spherical[:, -1]
    uniform_objs = uniform[:, :-1] / 10
    uniform_sets = uniform[:, -1]








.. GENERATED FROM PYTHON SOURCE LINES 27-29

Create reference set and reference point.


.. GENERATED FROM PYTHON SOURCE LINES 29-33

.. code-block:: Python


    ref_set = moocore.filter_dominated(np.vstack((spherical_objs, uniform_objs)))
    ref_point = 1.1








.. GENERATED FROM PYTHON SOURCE LINES 34-36

Calculate metrics.


.. GENERATED FROM PYTHON SOURCE LINES 36-67

.. code-block:: Python


    uniform_igd_plus = moocore.apply_within_sets(
        uniform_objs, uniform_sets, moocore.igd_plus, ref=ref_set
    )
    spherical_igd_plus = moocore.apply_within_sets(
        spherical_objs, spherical_sets, moocore.igd_plus, ref=ref_set
    )

    uniform_epsilon = moocore.apply_within_sets(
        uniform_objs, uniform_sets, moocore.epsilon_mult, ref=ref_set
    )
    spherical_epsilon = moocore.apply_within_sets(
        spherical_objs, spherical_sets, moocore.epsilon_mult, ref=ref_set
    )

    uniform_hypervolume = moocore.apply_within_sets(
        uniform_objs, uniform_sets, moocore.hypervolume, ref=ref_point
    )
    spherical_hypervolume = moocore.apply_within_sets(
        spherical_objs, spherical_sets, moocore.hypervolume, ref=ref_point
    )

    print(f"""
                Uniform       Spherical
                -------       ---------
    Mean HV  :  {np.mean(uniform_hypervolume):.5f}       {np.mean(spherical_hypervolume):.5f}
    Mean IGD+:  {np.mean(uniform_igd_plus):.5f}       {np.mean(spherical_igd_plus):.5f}
    Mean eps*:  {np.mean(uniform_epsilon):.3f}       {np.mean(spherical_epsilon):.3f}

    """)





.. rst-class:: sphx-glr-script-out

 .. code-block:: none


                Uniform       Spherical
                -------       ---------
    Mean HV  :  0.78689       0.73290
    Mean IGD+:  0.12383       0.15745
    Mean eps*:  623.278       225.916






.. GENERATED FROM PYTHON SOURCE LINES 68-73

IGD and Average Hausdorff are not Pareto-compliant
--------------------------------------------------

Example 4 by :cite:t:`IshMasTanNoj2015igd` shows a case where IGD gives the wrong answer.


.. GENERATED FROM PYTHON SOURCE LINES 73-78

.. code-block:: Python


    ref = np.array([10, 0, 6, 1, 2, 2, 1, 6, 0, 10]).reshape(-1, 2)
    A = np.array([4, 2, 3, 3, 2, 4]).reshape(-1, 2)
    B = np.array([8, 2, 4, 4, 2, 8]).reshape(-1, 2)








.. GENERATED FROM PYTHON SOURCE LINES 79-81

Assuming minimization of both objectives, A is better than B in terms of Pareto optimality.


.. GENERATED FROM PYTHON SOURCE LINES 81-98

.. code-block:: Python


    import pandas as pd
    import matplotlib.pyplot as plt
    import seaborn as sns

    sns.set_theme()

    df = pd.concat(
        [
            pd.DataFrame({"f1": x[:, 0], "f2": x[:, 1], "Set": label})
            for x, label in zip([ref, A, B], ["Ref", "A", "B"])
        ],
        ignore_index=True,
    )
    ax = sns.scatterplot(data=df, x="f1", y="f2", style="Set", hue="Set", s=200)
    plt.show()




.. image-sg:: /auto_examples/images/sphx_glr_plot_metrics_001.png
   :alt: plot metrics
   :srcset: /auto_examples/images/sphx_glr_plot_metrics_001.png, /auto_examples/images/sphx_glr_plot_metrics_001_2_00x.png 2.00x
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 99-106

However, both :func:`moocore.igd` and :func:`moocore.avg_hausdorff_dist`
incorrectly measure B as better than A, whereas :func:`moocore.igd_plus`,
:func:`moocore.r2_exact` and :func:`moocore.hypervolume` correctly measure A
as better than B (remember that hypervolume must be maximized) and
:func:`moocore.epsilon_additive` measures both as equally good
(epsilon is weakly Pareto compliant).


.. GENERATED FROM PYTHON SOURCE LINES 107-129

.. code-block:: Python


    pd.DataFrame(
        dict(
            A=[
                moocore.igd(A, ref),
                moocore.avg_hausdorff_dist(A, ref),
                moocore.igd_plus(A, ref),
                moocore.epsilon_additive(A, ref),
                moocore.hypervolume(A, ref=10),
                moocore.r2_exact(A, ref=0),
            ],
            B=[
                moocore.igd(B, ref),
                moocore.avg_hausdorff_dist(B, ref),
                moocore.igd_plus(B, ref),
                moocore.epsilon_additive(B, ref),
                moocore.hypervolume(B, ref=10),
                moocore.r2_exact(B, ref=0),
            ],
        ),
        index=["IGD", "Hausdorff", "IGD+", "eps+", "HV", "Exact R2"],
    )





.. raw:: html

    <div class="output_subarea output_html rendered_html output_result">
    <div>
    <style scoped>
        .dataframe tbody tr th:only-of-type {
            vertical-align: middle;
        }

        .dataframe tbody tr th {
            vertical-align: top;
        }

        .dataframe thead th {
            text-align: right;
        }
    </style>
    <table border="1" class="dataframe">
      <thead>
        <tr style="text-align: right;">
          <th></th>
          <th>A</th>
          <th>B</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <th>IGD</th>
          <td>3.707092</td>
          <td>2.591483</td>
        </tr>
        <tr>
          <th>Hausdorff</th>
          <td>3.707092</td>
          <td>2.591483</td>
        </tr>
        <tr>
          <th>IGD+</th>
          <td>1.482843</td>
          <td>2.260113</td>
        </tr>
        <tr>
          <th>eps+</th>
          <td>2.000000</td>
          <td>2.000000</td>
        </tr>
        <tr>
          <th>HV</th>
          <td>61.000000</td>
          <td>44.000000</td>
        </tr>
        <tr>
          <th>Exact R2</th>
          <td>1.630952</td>
          <td>2.066667</td>
        </tr>
      </tbody>
    </table>
    </div>
    </div>
    <br />
    <br />


.. rst-class:: sphx-glr-timing

   **Total running time of the script:** (0 minutes 0.289 seconds)


.. _sphx_glr_download_auto_examples_plot_metrics.py:

.. only:: html

  .. container:: sphx-glr-footer sphx-glr-footer-example

    .. container:: sphx-glr-download sphx-glr-download-jupyter

      :download:`Download Jupyter notebook: plot_metrics.ipynb <plot_metrics.ipynb>`

    .. container:: sphx-glr-download sphx-glr-download-python

      :download:`Download Python source code: plot_metrics.py <plot_metrics.py>`

    .. container:: sphx-glr-download sphx-glr-download-zip

      :download:`Download zipped: plot_metrics.zip <plot_metrics.zip>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
