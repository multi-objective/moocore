[{"path":"https://multi-objective.github.io/moocore/r/articles/benchmarks.html","id":"identifying-nondominated-points","dir":"Articles","previous_headings":"","what":"Identifying (non)dominated points","title":"Benchmarks","text":"following plots compare speed finding (non)dominated solutions, equivalent moocore::is_nondominated(), 2D, 3D, 4D 10D. plots show moocore always faster bbotk.","code":"setup <- quote({   stopifnot(nrow(x) >= N)   z <- x[1:N, ]   tz <- t(z) })  expr.list <- list(   moocore = quote(moocore::is_nondominated(z)),   bbotk = quote(bbotk::is_dominated(tz)))  files <- list(   \"test2D-200k\"=list(dataset=\"test2D-200k.inp.xz\", N=geomspace(1000, 50000, 10)),   \"ran3d-40k\"=list(dataset=\"ran.40000pts.3d.1.xz\", N=geomspace(1000, 40000, 10)),   \"ran4d\"=list(dataset=\"ran.9000pts.4d.10.xz\", N=geomspace(1000, 30000, 10)),   \"rmnk-10d\"=list(dataset=\"rmnk_0.0_10_16_1_0_random_search_1.txt.xz\", N=geomspace(1000, 20000, 10)) )  for (name in names(files)) {   p <- benchmark(name = name, x = get_dataset(files[[name]]$dataset, filter=FALSE),     N = files[[name]]$N, prefix=\"ndom\", title = \"is_(non)dominated()\",     setup = setup,  expr.list = expr.list)   print(p) }"},{"path":"https://multi-objective.github.io/moocore/r/articles/benchmarks.html","id":"exact-computation-of-hypervolume","dir":"Articles","previous_headings":"","what":"Exact computation of hypervolume","title":"Benchmarks","text":"following plots compare speed computing hypervolume indicator 3D, 4D, 5D 6D.  plots show, moocore always faster emoa , hence, faster GPareto, mlr3mbo, rmoo bbotk.","code":"setup <- quote({   ref <- colMaxs(x, useNames = FALSE) + 1   stopifnot(nrow(x) >= N)   z <- x[1:N, ]   tz <- t(z) })  expr.list <- list(   moocore = quote(moocore::hypervolume(z, ref = ref)),   emoa = quote(emoa::dominated_hypervolume(tz, ref = ref)))  files <- list(   \"DTLZLinearShape.3d\"=list(     dataset = \"DTLZLinearShape.3d.front.1000pts.10\",     N = seq(1000, 6000, 1000)),   \"DTLZLinearShape.4d\"=list(     dataset = \"DTLZLinearShape.4d.front.1000pts.10\",     N = seq(700, 1500, 100)),   \"DTLZLinearShape.5d\"=list(     dataset = \"DTLZLinearShape.5d.front.500pts.10\",     N = seq(400, 1000, 100)),   \"DTLZLinearShape.6d\"=list(     dataset = \"DTLZLinearShape.6d.front.700pts.10.xz\",     N = seq(200, 700, 100)) ) for (name in names(files)) {   p <- benchmark(name = name, x = get_dataset(files[[name]]$dataset, filter=TRUE),     N = files[[name]]$N, prefix=\"hv\", title = \"HV Computation\",     setup = setup,  expr.list = expr.list)   print(p) }"},{"path":"https://multi-objective.github.io/moocore/r/articles/benchmarks.html","id":"hypervolume-contribution","dir":"Articles","previous_headings":"","what":"Hypervolume contribution","title":"Benchmarks","text":"R package, moocore, able compute hypervolume contributions moocore::hv_contributions() emoa. However, emoa buggy calculates wrong values (olafmersmann/emoa#1).","code":""},{"path":"https://multi-objective.github.io/moocore/r/articles/eaf.html","id":"the-auc-of-the-eaf-and-the-aoc-hypervolume","dir":"Articles","previous_headings":"","what":"The AUC of the EAF and the AOC (Hypervolume)","title":"Empirical Attainment Function (EAF)","text":"Area---Curve (.e., hypervolume) set nondominated sets exactly Area---Curve (AUC) corresponding EAF (López-Ibáñez et al. 2025), example shows.","code":"library(moocore) library(tidyr) library(ggplot2)  extdata_dir <- system.file(package=\"moocore\", \"extdata\") A <- read_datasets(file.path(extdata_dir, \"ALG_1_dat.xz\")) A[,1:2] <- normalise(A[,1:2], to_range = c(0,1))  aoc <- mean(sapply(split.data.frame(A[,1:2], A[,3]), hypervolume, reference = 1)) eaf_a <- eaf(A[,1:2], A[,3]) eaf_a[,3] <- eaf_a[,3]/100 auc <- hypervolume(eaf_a, reference = c(1,1,0), maximise = c(FALSE,FALSE,TRUE)) nruns <- length(unique(A[,3])) cat(\"Runs = \", nruns,     \"\\nAUC of EAF = \", auc,     \"\\nMean AOC = \", aoc, \"\\n\") #> Runs =  90  #> AUC of EAF =  0.7452171  #> Mean AOC =  0.7452171  runs <- 5:nruns aocs <- c() aucs <- c() for (r in runs) {   a <- A[A[,3] <= r, ]   aoc <- mean(sapply(split.data.frame(a[,1:2], a[,3]), hypervolume, reference = 1))   eaf_a <- eaf(a[,1:2], a[,3])   eaf_a[,3] <- eaf_a[,3]/100   auc <- hypervolume(eaf_a, reference = c(1,1,0), maximise = c(FALSE,FALSE,TRUE))   aocs <- c(aocs, aoc)   aucs <- c(aucs, auc) }  x <- tibble(r = runs, AOC = aocs, AUC=aucs) %>% pivot_longer(-r, names_to = \"variable\", values_to = \"value\") ggplot(x, aes(r, value, color=variable, linetype=variable)) +   geom_line(linewidth=1.5) +   labs(x = \"Number of sets\", y = \"Value\", color = \"\", linetype = \"\")"},{"path":[]},{"path":"https://multi-objective.github.io/moocore/r/articles/generate.html","id":"random-nondominated-sets-in-2d","dir":"Articles","previous_headings":"","what":"Random nondominated sets in 2D","title":"Sampling Random Nondominated Sets","text":"","code":"n <- 100 methods <- c(\"simplex\", \"concave-sphere\", \"convex-sphere\", \"convex-simplex\") colors <- c(\"red\", \"blue\", \"green\", \"purple\") shapes <- c(16, 15, 17, 18)  # ggplot2 shape codes  df_all <- do.call(rbind.data.frame, lapply(methods, function(method) {   points <- moocore::generate_ndset(n, 2, method = method, seed = 42)   data.frame(x = points[,1L], y = points[,2L], method = method) }))  ggplot(df_all, aes(x = x, y = y, color = method, shape = method)) +   geom_point(size = 2) +   scale_color_manual(values = colors) +   scale_shape_manual(values = shapes) +   theme_minimal() +   labs(x = expression(z[1]), y = expression(z[2]),     title = \"Random Nondominated Sets (2D)\")"},{"path":"https://multi-objective.github.io/moocore/r/articles/generate.html","id":"random-nondominated-sets-in-integer-space","dir":"Articles","previous_headings":"","what":"Random nondominated sets in integer space","title":"Sampling Random Nondominated Sets","text":"can also generate points integer space.","code":"points_list <- lapply(methods, function(method) {   moocore::generate_ndset(n, 2, method = method, seed = 42, integer = TRUE) }) max_list <- sapply(points_list, max) maximum <- max(max_list)  df_int <- do.call(rbind, lapply(seq_along(points_list), function(i) {   x <- points_list[[i]]   if (max_list[i] < maximum)     x <- moocore::normalise(x, lower = 0, upper = max_list[i], to_range = c(0, maximum))   data.frame(x = x[,1], y = x[,2], method = methods[i]) }))  ggplot(df_int, aes(x = x, y = y, color = method, shape = method)) +   geom_point(size = 2) +   scale_color_manual(values = colors) +   scale_shape_manual(values = shapes) +   theme_minimal() +   labs(x = expression(z[1]), y = expression(z[2]),     title = \"Random Nondominated Sets in Integer Space (2D)\")"},{"path":"https://multi-objective.github.io/moocore/r/articles/generate.html","id":"variants-of-convex-nondominated-sets","dir":"Articles","previous_headings":"","what":"Variants of convex nondominated sets","title":"Sampling Random Nondominated Sets","text":"popular way generate convex nondominated set translate negative orthant hyper-sphere unit hyper-cube (convex-sphere). However, possible convex sets different properties. example method convex-simplex applies non-linear transformation concave-sphere set, resulting convex transformation standard simplex.","code":"library(moocore) library(htmltools) library(plotly, warn.conflicts = FALSE)  plot_3d <- function(what, x, title) {   p <- plot_ly()    if (what == \"simplex\") {     # 2-simplex mesh     x_s <- diag(3)     p <- p %>% add_trace(       type = \"mesh3d\",       x = x_s[, 1L],       y = x_s[, 2L],       z = x_s[, 3L],       i = 0, j = 1, k = 2,       color = \"cyan\",       opacity = 0.2,       flatshading = TRUE,       name = \"Simplex\"     )   } else if (what %in% c(\"concave\", \"convex\")) {     n_grid <- 50     phi <- seq(0, pi/2, length.out = n_grid)     theta <- seq(0, pi/2, length.out = n_grid)     grid <- expand.grid(phi = phi, theta = theta)      x_s <- matrix(sin(grid$phi) * cos(grid$theta), nrow = n_grid)     y_s <- matrix(sin(grid$phi) * sin(grid$theta), nrow = n_grid)     z_s <- matrix(cos(grid$phi), nrow = n_grid)      if (what == \"convex\") {       x_s <- 1 - x_s       y_s <- 1 - y_s       z_s <- 1 - z_s     }      p <- p %>% add_surface(       x = x_s,       y = y_s,       z = z_s,       colorscale = list(c(0, \"cyan\"), c(1, \"cyan\")),       opacity = 0.2,       showscale = FALSE     )   }    # Add scatter points   p <- p %>% add_trace(     type = \"scatter3d\",     mode = \"markers\",     x = x[, 1L],     y = x[, 2L],     z = x[, 3L],     marker = list(size = 2, color = \"blue\")   )    # Layout   p %>% layout(     title = title,     scene = list(       xaxis = list(title = \"Z1\", range = c(0,1)),       yaxis = list(title = \"Z2\", range = c(0,1)),       zaxis = list(title = \"Z3\", range = c(0,1)),       camera = list(eye = list(x = 1.2, y = 1.2, z = 0.8))     ),     margin = list(l = 0, r = 0, b = 0, t = 40),     showlegend = FALSE   ) }  plotly_side_by_side <- function(fig1, fig2, height=\"500px\") {   browsable(     tags$div(style=\"display:flex; justify-content: space-between;\",       tags$div(style=sprintf(\"width:49%%; height:%s;\", height),         plotly::as_widget(fig1)),       tags$div(style=sprintf(\"width:49%%; height:%s;\", height),         plotly::as_widget(fig2)))) } n <- 2000  points1 <- moocore::generate_ndset(n, 3, \"convex-sphere\", seed = 42) fig1 <- plot_3d(\"simplex\", points1, title = \"Convex-sphere\")  points2 <- moocore::generate_ndset(n, 3, \"convex-simplex\", seed = 42) fig2 <- plot_3d(\"simplex\", points2, title = \"Convex-simplex\")  plotly_side_by_side(fig1, fig2)"},{"path":"https://multi-objective.github.io/moocore/r/articles/generate.html","id":"uniform-sampling-moocore-vs-projections-of-uniform-samples-naive","dir":"Articles","previous_headings":"","what":"Uniform sampling (moocore) vs projections of uniform samples (naive)","title":"Sampling Random Nondominated Sets","text":"Naive methods sampling sets usually sample points uniformly hypercube project lower dimensional manifold (Lacour, Klamroth, Fonseca 2017), e.g., standard simplex positive orthant hypersphere. However, projections preserve uniformity sampling, , points manifold probability sampled. function moocore::generate_ndset() produces uniform sampling manifold, shown following examples:","code":"n <- 2000  # Simplex points_moocore <- moocore::generate_ndset(n, 3, \"simplex\", seed = 42) points_naive <- matrix(runif(n * 3), n, 3) points_naive <- points_naive / rowSums(points_naive)  fig1 <- plot_3d(\"simplex\", points_moocore, title = \"Simplex (moocore)\") fig2 <- plot_3d(\"simplex\", points_naive, title = \"Simplex (naive)\") plotly_side_by_side(fig1, fig2) # Concave-sphere points_moocore <- moocore::generate_ndset(n, 3, \"concave-sphere\", seed = 42) points_naive <- matrix(runif(n * 3), n, 3) points_naive <- points_naive / sqrt(rowSums(points_naive^2))  fig1 <- plot_3d(\"concave\", points_moocore, title = \"Concave-sphere (moocore)\") fig2 <- plot_3d(\"concave\", points_naive, title = \"Concave-sphere (naive)\") plotly_side_by_side(fig1, fig2) # Convex-sphere points_moocore <- moocore::generate_ndset(n, 3, \"convex-sphere\", seed = 42) points_naive <- 1 - points_naive  fig1 <- plot_3d(\"convex\", points_moocore, title = \"Convex-sphere (moocore)\") fig2 <- plot_3d(\"convex\", points_naive, title = \"Convex-sphere (naive)\") plotly_side_by_side(fig1, fig2)"},{"path":[]},{"path":"https://multi-objective.github.io/moocore/r/articles/hv_approx.html","id":"comparing-hype-and-dz2019","dir":"Articles","previous_headings":"","what":"Comparing HypE and DZ2019","title":"Approximating the hypervolume","text":"example shows approximate hypervolume metric CPFs.txt dataset using whv_hype() (HypE), hv_approx() (DZ2019) several values number samples 10110^1 10510^5. repeat calculation 10 times account stochasticity. First calculate exact hypervolume. Next, approximate hypervolume using {101,102,…,105}\\{10^1, 10^2, \\ldots, 10^5\\} random samples show higher samples reduce approximation error. Since approximation stochastic, perform 10 repetitions computation. Next, plot results.","code":"ref <- 2.1 data(CPFs) x <- filter_dominated(CPFs[,1:2]) x <- normalise(x, to_range=c(1, 2)) true_hv <- hypervolume(x, reference = ref) true_hv #> [1] 1.057045 nreps <- 10 nsamples_exp <- 5 set.seed(42) results <- list(\"HypE\" = list(), \"DZ2019-HW\" = list(), \"DZ2019-MC\" = list()) df <- data.frame(Method=character(), rep=integer(), samples=numeric(), value=numeric())  for (i in seq_len(nsamples_exp)) {   df <- rbind(df,     # We use rep=c(1,1) to silence a ggplot2 warning with mean_cl_boot.     data.frame(Method=\"DZ2019-HW\", rep=c(1,1), samples=10^i,       value = hv_approx(x, reference = ref, nsamples = 10^i, method=\"DZ2019-HW\")),     data.frame(Method=\"HypE\", rep=seq_len(nreps), samples=10^i,       value = sapply(seq_len(nreps), function(r)         whv_hype(x, reference = ref, ideal = 0, nsamples = 10^i, seed = 42 + r))),     data.frame(Method=\"DZ2019-MC\", rep=seq_len(nreps), samples=10^i,       value = sapply(seq_len(nreps), function(r)         hv_approx(x, reference = ref, nsamples = 10^i, seed = 42 + r, method=\"DZ2019-MC\")))     ) } df[[\"error\"]] <- abs(df[[\"value\"]] - true_hv) / true_hv res <- df %>% filter(samples == max(samples)) %>% group_by(Method) %>%   summarise(Mean = mean(value), Min = min(value), Max = max(value)) width <- nchar(\"Mean of DZ2019-MC\") text <- c(sprintf(\"%*s : %.12f\", width, \"True HV\", true_hv),   sapply(res$Method, function(method)   sprintf(\"%*s : %.12f  [min, max] = [%.12f, %.12f]\", width,     paste0(\"Mean of \", method),     res[res$Method == method, \"Mean\"],     res[res$Method == method, \"Min\"],     res[res$Method == method, \"Max\"]))) cat(sep=\"\\n\", text) #>           True HV : 1.057044746430 #> Mean of DZ2019-HW : 1.057044746450  [min, max] = [1.057044746450, 1.057044746450] #> Mean of DZ2019-MC : 1.057090931199  [min, max] = [1.056607935350, 1.057665468167] #>      Mean of HypE : 1.057059359998  [min, max] = [1.046272499998, 1.063736099998] library(ggplot2) library(scales) ggplot(df, aes(samples, error, color=Method)) +   stat_summary(fun = mean, geom = \"line\") +   stat_summary(fun.data = mean_cl_boot, geom = \"ribbon\", color = NA, alpha=0.2,     mapping=aes(fill=Method)) +   scale_x_log10(labels = label_log()) +   scale_y_log10(labels = label_log()) +   labs(x = \"Samples\", y = \"Relative Error\") +   theme_bw()"},{"path":"https://multi-objective.github.io/moocore/r/articles/hv_approx.html","id":"comparing-monte-carlo-and-quasi-monte-carlo-approximations","dir":"Articles","previous_headings":"","what":"Comparing Monte-Carlo and quasi-Monte-Carlo approximations","title":"Approximating the hypervolume","text":"quasi-Monte-Carlo approximation method=DZ2019-HW deterministic, monotonic number samples. Nevertheless, tends better Monte-Carlo approximation generated method=DZ2019-MC, specially large number objectives.","code":"library(moocore) library(ggplot2) library(scales) datasets <- c(\"DTLZLinearShape.8d.front.60pts.10\", \"ran.10pts.9d.10\") ref <- 10 samples <- 2 ** (12:19) maxiter <- max(samples) df <- NULL for (dataset in datasets) {   x <- read_datasets(system.file(file.path(\"extdata\", dataset),     package=\"moocore\", mustWork=TRUE))   x <- x[, -ncol(x)] # Union of datasets.   x <- filter_dominated(x)[1:10, ]   exact <- hypervolume(x, reference=ref)   res <- list(     data.frame(Method=\"HW\", samples = samples, seed = NA,       hv = sapply(samples, function(i)         hv_approx(x, reference=ref, nsamples=i, method=\"DZ2019-HW\"))))   # Duplicate the observations to avoid a warning with mean_cl_boot   res <- c(res, res)   for (k in 1:10) {     seed <- 42 + k     res <- c(res, list(       data.frame(Method=\"MC\", samples = samples, seed = seed,         hv = sapply(samples, function(i)           hv_approx(x, reference=ref, nsamples=i, method=\"DZ2019-MC\", seed=seed)))))   }   res <- do.call(\"rbind\", res)   res[[\"hverror\"]] <- abs(1.0 - (res$hv / exact))   res[[\"dataset\"]] <- dataset   df <- rbind(df, res) } ggplot(df, aes(x = samples, y = hverror, color = Method)) +   stat_summary(fun = mean, geom = \"line\") +   stat_summary(fun = mean, geom = \"point\") +   stat_summary(fun.data = mean_cl_boot, geom = \"ribbon\", color = NA, alpha=0.2,     mapping=aes(fill=Method)) +   scale_y_log10(labels = label_log(), breaks = 10^(-5:5)) +   scale_x_continuous(trans = \"log2\", labels = label_log(base=2)) +   labs(x = \"Samples\", y = \"Relative error\") +   facet_wrap(~dataset, scales=\"free_y\",nrow=2) +   theme_bw()"},{"path":"https://multi-objective.github.io/moocore/r/articles/metrics.html","id":"comparing-two-multi-objective-datasets-using-unary-quality-metrics","dir":"Articles","previous_headings":"","what":"Comparing two multi-objective datasets using unary quality metrics","title":"Computing Multi-Objective Quality Metrics","text":"First, read datasets: Create reference set reference point: Calculate metrics:","code":"spherical <- get_dataset(\"spherical-250-10-3d.txt\") uniform <- get_dataset(\"uniform-250-10-3d.txt\")  spherical_objs <- spherical[, -ncol(spherical)] spherical_sets <- spherical[, ncol(spherical)] uniform_objs <- uniform[, -ncol(uniform)] / 10 uniform_sets <- uniform[, ncol(uniform)] ref_set <- filter_dominated(rbind(spherical_objs, uniform_objs)) ref_point <- 1.1 uniform_igd_plus <- apply_within_sets(uniform_objs, uniform_sets,   igd_plus, ref = ref_set) spherical_igd_plus <- apply_within_sets(spherical_objs, spherical_sets,   igd_plus, ref = ref_set)  uniform_epsilon <- apply_within_sets(uniform_objs, uniform_sets,   epsilon_mult, ref = ref_set) spherical_epsilon <- apply_within_sets(spherical_objs, spherical_sets,   epsilon_mult, ref = ref_set)  uniform_hypervolume <- apply_within_sets(uniform_objs, uniform_sets,   hypervolume, ref = ref_point) spherical_hypervolume <- apply_within_sets(spherical_objs, spherical_sets,   hypervolume, ref = ref_point)  knitr::kable(data.frame(   Uniform = c(mean(uniform_hypervolume), mean(uniform_igd_plus),     mean(uniform_epsilon)),   Spherical = c(mean(spherical_hypervolume), mean(spherical_igd_plus),     mean(spherical_epsilon)),   row.names = c(\"Mean HV\",\"Mean IGD+\",\"Mean eps*\")), format = \"html\") %>%   kableExtra::kable_styling(position = \"center\",     bootstrap_options = c(\"striped\", \"condensed\", \"responsive\"))"},{"path":"https://multi-objective.github.io/moocore/r/articles/metrics.html","id":"igd-and-average-hausdorff-are-not-pareto-compliant","dir":"Articles","previous_headings":"","what":"IGD and Average Hausdorff are not Pareto-compliant","title":"Computing Multi-Objective Quality Metrics","text":"Example 4 Ishibuchi et al. (2015) shows case IGD gives wrong answer:  Assuming minimization objectives, AA better BB terms Pareto optimality. However, igd() avg_hausdorff_dist() incorrectly measure BB better AA, whereas r2_exact(), igd_plus() hypervolume() correctly measure AA better BB (remember hypervolume must maximized) epsilon_additive() measures equally good (epsilon weakly Pareto compliant).","code":"ref <- matrix(c(10, 0, 6, 1, 2, 2, 1, 6, 0, 10), ncol = 2, byrow=TRUE) A <- matrix(c(4, 2, 3, 3, 2, 4), ncol = 2, byrow=TRUE) B <- matrix(c(8, 2, 4, 4, 2, 8), ncol = 2, byrow=TRUE)  par(mar = c(4, 4, 1, 1)) # Reduce empty margins plot(ref, xlab=expression(f[1]), ylab=expression(f[2]),   panel.first=grid(nx=NULL), pch=23, bg=\"gray\", cex=1.5) points(A, pch=1, cex=1.5) points(B, pch=19, cex=1.5) legend(\"topright\", legend=c(\"Reference\", \"A\", \"B\"), pch=c(23,1,19),   pt.bg=\"gray\", bg=\"white\", bty = \"n\", pt.cex=1.5, cex=1.2) knitr::kable(   data.frame(     A = c(         igd(A, ref),         avg_hausdorff_dist(A, ref),         igd_plus(A, ref),         epsilon_additive(A, ref),         hypervolume(A, ref=10),         r2_exact(A, ref=0)),     B = c(         igd(B, ref),         avg_hausdorff_dist(B, ref),         igd_plus(B, ref),         epsilon_additive(B, ref),         hypervolume(B, ref=10),         r2_exact(B, ref=0)),     row.names=c(\"IGD\", \"Hausdorff\", \"IGD+\", \"eps+\", \"HV\", \"Exact R2\")), format = \"html\") %>%   kableExtra::kable_styling(position = \"center\",     bootstrap_options = c(\"striped\", \"condensed\", \"responsive\"))"},{"path":[]},{"path":"https://multi-objective.github.io/moocore/r/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Manuel López-Ibáñez. Author, maintainer. Carlos Fonseca. Contributor. Luís Paquete. Contributor. Andreia P. Guerreiro. Contributor. Mickaël Binois. Contributor. Michael H. Buselli. Copyright holder.           AVL-tree library Wessel Dankers. Copyright holder.           AVL-tree library NumPy Developers. Copyright holder.           RNG ziggurat constants Jean-Sebastien Roy. Copyright holder.           mt19937 library Makoto Matsumoto. Copyright holder.           mt19937 library Takuji Nishimura. Copyright holder.           mt19937 library","code":""},{"path":"https://multi-objective.github.io/moocore/r/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"López-Ibáñez M (2026). moocore: Core Mathematical Functions Multi-Objective Optimization. R package version 0.2.0.900, https://multi-objective.github.io/moocore/r/.","code":"@Manual{,   title = {moocore: Core Mathematical Functions for Multi-Objective Optimization},   author = {Manuel López-Ibáñez},   year = {2026},   note = {R package version 0.2.0.900},   url = {https://multi-objective.github.io/moocore/r/}, }"},{"path":"https://multi-objective.github.io/moocore/r/index.html","id":"moocore-core-algorithms-for-multi-objective-optimization","dir":"","previous_headings":"","what":"Core Mathematical Functions for Multi-Objective Optimization","title":"Core Mathematical Functions for Multi-Objective Optimization","text":"[ Homepage ] [ GitHub ] Maintainer: Manuel López-Ibáñez Contributors: Manuel López-Ibáñez, Carlos M. Fonseca, Luís Paquete, Mickaël Binois.","code":""},{"path":"https://multi-objective.github.io/moocore/r/index.html","id":"introduction","dir":"","previous_headings":"","what":"Introduction","title":"Core Mathematical Functions for Multi-Objective Optimization","text":"webpage documents moocore R package. also moocore Python package goal moocore project collect document fast implementations core mathematical functions algorithms multi-objective optimization make available different programming languages via similar interfaces. functions include: Generate transform nondominated sets. Identify filter dominated vectors. Quality metrics (weighted) hypervolume, epsilon, IGD, etc. Computation Empirical Attainment Function. empirical attainment function (EAF) describes probabilistic distribution outcomes obtained stochastic algorithm objective space. critical functionality implemented C, R Python packages providing convenient interfaces C code. Keywords: empirical attainment function, summary attainment surfaces, EAF differences, multi-objective optimization, bi-objective optimization, performance measures, performance assessment Relevant literature: Manuel López-Ibáñez, Luís Paquete, Thomas Stützle. Exploratory Analysis Stochastic Local Search Algorithms Biobjective Optimization. T. Bartz-Beielstein, M. Chiarandini, L. Paquete, M. Preuss, editors, Experimental Methods Analysis Optimization Algorithms, pages 209–222. Springer, Berlin, Germany, 2010. (chapter also available slightly extended form Technical Report TR/IRIDIA/2009-015). [ bibtex | doi: 10.1007/978-3-642-02538-9_9 | Presentation ]","code":""},{"path":"https://multi-objective.github.io/moocore/r/index.html","id":"download-and-installation","dir":"","previous_headings":"","what":"Download and installation","title":"Core Mathematical Functions for Multi-Objective Optimization","text":"moocore package implemented R. Therefore, basic knowledge R recommended make use features. first step installing moocore package install R. R installed system, two methods installing moocore package: Install within R (automatic download, internet connection required). Invoke R, Download moocore package CRAN (may also need download install first package matrixStats), invoke command-line: <package> one three versions available: .tar.gz (Unix/BSD/GNU/Linux), .tgz (MacOS X), .zip (Windows). Search R documentation need help install R package system. Compiled command-line executables various purposes can found system.file(package=\"moocore\", \"bin\"). wish notified bugfixes new versions, please subscribe low-volume emo-list, announcements made. [ Download moocore package CRAN ] [ Documentation ] [ Development version (GitHub) ]","code":"install.packages(\"moocore\") R CMD INSTALL <package>"},{"path":"https://multi-objective.github.io/moocore/r/index.html","id":"github-development-version","dir":"","previous_headings":"","what":"GitHub (Development version)","title":"Core Mathematical Functions for Multi-Objective Optimization","text":"wish try development version, can install executing following command within R console:","code":"install.packages('moocore', repos = c('https://multi-objective.r-universe.dev', 'https://cloud.r-project.org'))"},{"path":"https://multi-objective.github.io/moocore/r/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"Core Mathematical Functions for Multi-Objective Optimization","text":"moocore package installed, following R commands give information:","code":"library(moocore)     ?eaf     ?read_datasets"},{"path":"https://multi-objective.github.io/moocore/r/index.html","id":"license","dir":"","previous_headings":"","what":"License","title":"Core Mathematical Functions for Multi-Objective Optimization","text":"software Copyright (C) 2024 Manuel López-Ibáñez, Carlos M. Fonseca, Luís Paquete, Mickaël Binois. program free software (software libre); can redistribute /modify terms GNU General Public License published Free Software Foundation; either version 2 License, (option) later version. program distributed hope useful, WITHOUT WARRANTY; without even implied warranty MERCHANTABILITY FITNESS PARTICULAR PURPOSE. See GNU General Public License details. IMPORTANT NOTE: Please aware fact program released Free Software excuse scientific propriety, obligates give appropriate credit! write scientific paper describing research made substantive use program, obligation scientist () mention fashion software used Methods section; (b) mention algorithm References section. appropriate citation : Manuel López-Ibáñez, Luís Paquete, Thomas Stützle. Exploratory Analysis Stochastic Local Search Algorithms Biobjective Optimization. T. Bartz-Beielstein, M. Chiarandini, L. Paquete, M. Preuss, editors, Experimental Methods Analysis Optimization Algorithms, pages 209–222. Springer, Berlin, Germany, 2010. doi: 10.1007/978-3-642-02538-9_9 Moreover, personal note, appreciate email manuel.lopez-ibanez@manchester.ac.uk citations papers referencing work can mention funding agent tenure committee.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/CPFs.html","id":null,"dir":"Reference","previous_headings":"","what":"Conditional Pareto fronts obtained from Gaussian processes simulations. — CPFs","title":"Conditional Pareto fronts obtained from Gaussian processes simulations. — CPFs","text":"data goal providing example use vorob_t() vorob_dev(). obtained fitting two Gaussian processes 20 observations bi-objective problem, generating conditional simulation GPs different locations extracting non-dominated values coupled simulations.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/CPFs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Conditional Pareto fronts obtained from Gaussian processes simulations. — CPFs","text":"","code":"CPFs"},{"path":"https://multi-objective.github.io/moocore/r/reference/CPFs.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Conditional Pareto fronts obtained from Gaussian processes simulations. — CPFs","text":"data frame 2967 observations following 3 variables. f1 first objective values. f2 second objective values. set indices corresponding conditional Pareto fronts.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/CPFs.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Conditional Pareto fronts obtained from Gaussian processes simulations. — CPFs","text":"Mickaël Binois, David Ginsbourger, Olivier Roustant (2015). “Quantifying uncertainty Pareto fronts Gaussian process conditional simulations.” European Journal Operational Research, 243(2), 386–394. doi:10.1016/j.ejor.2014.07.032 .","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/CPFs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Conditional Pareto fronts obtained from Gaussian processes simulations. — CPFs","text":"","code":"data(CPFs) vorob_t(CPFs, reference = c(2, 200)) #> $threshold #> [1] 44.14062 #>  #> $ve #>               [,1]      [,2] #>   [1,] -37.5978423 -10.79646 #>   [2,] -37.4804644 -11.53365 #>   [3,] -37.0991315 -13.28225 #>   [4,] -36.8538299 -13.51379 #>   [5,] -35.9143692 -15.88340 #>   [6,] -33.7273974 -16.62457 #>   [7,] -33.6535102 -16.82444 #>   [8,] -33.1511911 -18.74396 #>   [9,] -32.9692979 -18.74794 #>  [10,] -31.9646706 -18.75199 #>  [11,] -31.7587126 -19.01094 #>  [12,] -31.5938459 -19.25569 #>  [13,] -31.0546051 -19.27765 #>  [14,] -29.9981435 -19.42665 #>  [15,] -29.7032739 -19.97302 #>  [16,] -28.8450841 -19.99701 #>  [17,] -28.7662560 -20.14155 #>  [18,] -28.7604414 -20.21210 #>  [19,] -28.6222054 -20.29300 #>  [20,] -28.6081935 -20.35386 #>  [21,] -27.5789696 -20.56612 #>  [22,] -27.4631376 -20.65248 #>  [23,] -26.6204447 -20.92707 #>  [24,] -25.7823451 -20.98034 #>  [25,] -25.7284367 -21.07042 #>  [26,] -25.2472705 -21.10899 #>  [27,] -25.2011926 -21.21124 #>  [28,] -25.1393615 -21.26280 #>  [29,] -24.6906978 -21.29381 #>  [30,] -24.4908478 -21.41502 #>  [31,] -23.5137561 -21.67388 #>  [32,] -23.3115825 -21.77622 #>  [33,] -23.0923337 -21.80502 #>  [34,] -22.7120508 -21.88500 #>  [35,] -21.2422296 -21.88748 #>  [36,] -20.7717958 -21.98188 #>  [37,] -20.5216678 -22.06040 #>  [38,] -19.4227481 -22.06195 #>  [39,] -19.4154587 -22.32430 #>  [40,] -19.1464967 -22.38983 #>  [41,] -18.7563892 -22.66689 #>  [42,] -18.5288873 -22.74792 #>  [43,] -17.2773218 -22.78154 #>  [44,] -15.3792174 -22.87815 #>  [45,] -15.0369845 -22.87827 #>  [46,] -14.1304836 -22.89749 #>  [47,] -13.6576356 -22.91511 #>  [48,] -13.4737509 -23.10140 #>  [49,] -12.5828793 -23.20047 #>  [50,] -12.5806182 -23.25464 #>  [51,] -12.4567703 -23.37415 #>  [52,] -12.1855012 -23.44729 #>  [53,] -11.8617280 -23.44904 #>  [54,] -11.7554838 -23.47981 #>  [55,] -11.2052699 -23.48659 #>  [56,]  -9.5701487 -23.50222 #>  [57,]  -9.1922152 -23.56067 #>  [58,]  -9.1141942 -23.59717 #>  [59,]  -8.7050441 -23.69267 #>  [60,]  -8.4556581 -23.88606 #>  [61,]  -8.2849670 -24.06901 #>  [62,]  -8.2392877 -24.09147 #>  [63,]  -8.0321385 -24.09929 #>  [64,]  -7.8725159 -24.12909 #>  [65,]  -7.4508325 -24.14180 #>  [66,]  -7.4474946 -24.19948 #>  [67,]  -7.2977411 -24.24551 #>  [68,]  -6.9845013 -24.27163 #>  [69,]  -6.8595590 -24.30992 #>  [70,]  -6.8388461 -24.38878 #>  [71,]  -6.2772159 -24.39190 #>  [72,]  -6.2175064 -24.41195 #>  [73,]  -6.0638418 -24.42932 #>  [74,]  -5.5502105 -24.45534 #>  [75,]  -5.0101700 -24.48061 #>  [76,]  -4.3447716 -24.50950 #>  [77,]  -3.0751063 -24.70106 #>  [78,]  -3.0329554 -24.81540 #>  [79,]  -2.7721849 -24.88356 #>  [80,]  -2.2829770 -24.95552 #>  [81,]  -1.9772500 -24.98507 #>  [82,]  -1.8284903 -25.09108 #>  [83,]  -1.7979003 -25.19219 #>  [84,]  -1.7099778 -25.27572 #>  [85,]  -0.3551225 -25.45475 #>  [86,]   1.4752205 -25.47433 #>  [87,]   1.6394106 -25.65990 #>  [88,]   2.1632632 -25.95665 #>  [89,]   3.3794879 -26.09472 #>  [90,]   3.5055396 -26.15303 #>  [91,]   3.8248183 -26.24308 #>  [92,]   4.0332572 -26.24397 #>  [93,]   4.1387790 -26.34159 #>  [94,]   4.3513727 -26.43825 #>  [95,]   6.3208813 -26.56214 #>  [96,]   7.2998707 -26.63191 #>  [97,]   9.3460150 -26.65485 #>  [98,]   9.5386116 -26.94045 #>  [99,]  10.3781974 -26.96751 #> [100,]  11.6804102 -26.96959 #> [101,]  14.4125986 -27.00102 #> [102,]  16.6933277 -27.01095 #> [103,]  17.8683518 -27.10385 #> [104,]  18.2756069 -27.65269 #> [105,]  19.4882347 -27.71717 #> [106,]  20.1816676 -27.89640 #> [107,]  21.3732947 -28.01213 #> [108,]  21.9884321 -28.08156 #> [109,]  22.0195376 -28.09682 #> [110,]  22.0288958 -28.26190 #> [111,]  23.3059424 -28.55590 #> [112,]  23.5153250 -28.56087 #> [113,]  24.7980488 -28.64589 #> [114,]  26.8934652 -28.66955 #> [115,]  27.0974155 -28.72620 #> [116,]  28.8806091 -28.89576 #> [117,]  29.0315353 -28.90785 #> [118,]  29.9601039 -28.93467 #> [119,]  30.5141538 -28.96768 #> [120,]  34.0007655 -29.07697 #> [121,]  34.2778379 -29.18076 #> [122,]  35.0459845 -29.26500 #> [123,]  35.8108691 -29.49194 #> [124,]  38.6075068 -29.80295 #> [125,]  39.6553751 -29.80366 #> [126,]  39.9937466 -29.81892 #> [127,]  41.0272025 -29.82227 #> [128,]  42.0504690 -29.88635 #> [129,]  45.6096523 -30.01872 #> [130,]  47.7046212 -30.02561 #> [131,]  49.2600525 -30.17545 #> [132,]  49.6427641 -30.40698 #> [133,]  53.0626287 -30.43793 #> [134,]  54.7697400 -30.50487 #> [135,]  54.9914959 -30.52316 #> [136,]  56.0850877 -30.71623 #> [137,]  56.8025563 -30.76961 #> [138,]  59.1633411 -30.92437 #> [139,]  59.5340987 -31.05449 #> [140,]  63.7214774 -31.15033 #> [141,]  63.9688708 -31.23838 #> [142,]  64.5288942 -31.31147 #> [143,]  68.2713249 -31.42743 #> [144,]  68.9108617 -31.45392 #> [145,]  69.8039471 -31.48788 #> [146,]  70.2719871 -31.50890 #> [147,]  72.6160142 -31.54263 #> [148,]  73.6628042 -31.54855 #> [149,]  73.9591043 -31.60323 #> [150,]  74.6389291 -31.64608 #> [151,]  75.2462156 -31.66217 #> [152,]  75.7353427 -31.70506 #> [153,]  76.9137031 -31.77816 #> [154,]  77.4465275 -31.80060 #> [155,]  77.5418527 -31.81632 #> [156,]  78.9251438 -31.84611 #> [157,]  79.5251958 -31.87112 #> [158,]  80.2261408 -31.87627 #> [159,]  81.1123543 -31.88464 #> [160,]  82.0887769 -31.89967 #> [161,]  82.2917624 -32.02414 #> [162,]  83.5546447 -32.04372 #> [163,]  84.1241591 -32.11488 #> [164,]  85.1042890 -32.29158 #> [165,]  85.9680606 -32.42294 #> [166,]  87.5788795 -32.43134 #> [167,]  88.3184250 -32.47432 #> [168,]  89.3680488 -32.47811 #> [169,]  90.9786234 -32.49957 #> [170,]  91.2025371 -32.52547 #> [171,]  92.6006520 -32.53529 #> [172,]  94.4332216 -32.58076 #> [173,]  95.4272615 -32.64220 #> [174,]  96.4968088 -32.65060 #> [175,]  97.8282433 -32.67302 #> [176,]  98.7716071 -32.71148 #> [177,] 100.5973901 -32.74339 #> [178,] 101.0167180 -32.84149 #> [179,] 102.0021813 -32.85672 #> [180,] 102.7220666 -32.87607 #> [181,] 103.0142379 -32.89849 #> [182,] 104.7393644 -32.93105 #> [183,] 104.8689570 -32.95066 #> [184,] 105.5736765 -33.07372 #> [185,] 106.4822534 -33.08142 #> [186,] 106.9804743 -33.14618 #> [187,] 107.2773119 -33.18751 #> [188,] 108.7657769 -33.20285 #> [189,] 109.0124631 -33.21556 #> [190,] 111.2330616 -33.24898 #> [191,] 111.4303834 -33.26963 #> [192,] 111.5961914 -33.28785 #> [193,] 117.1455263 -33.31951 #> [194,] 117.5839258 -33.37224 #> [195,] 117.7582125 -33.37834 #> [196,] 118.2947053 -33.38737 #> [197,] 118.5338082 -33.43432 #> [198,] 119.5898708 -33.44875 #> [199,] 122.0554270 -33.45548 #> [200,] 123.9807878 -33.48766 #> [201,] 124.4892353 -33.50264 #> [202,] 124.8585753 -33.51050 #> [203,] 127.1357276 -33.51250 #> [204,] 128.3280870 -33.57118 #> [205,] 129.3665563 -33.57142 #> [206,] 129.9706893 -33.61145 #> [207,] 131.7867643 -33.61878 #> [208,] 134.6726692 -33.66297 #> [209,] 135.3907127 -33.67311 #> [210,] 138.4449707 -33.69634 #> [211,] 138.5130531 -33.69958 #> [212,] 139.4607302 -33.73302 #> [213,] 168.0747723 -33.76486 #>  #> $avg_hyp #> [1] 8943.333 #>"},{"path":"https://multi-objective.github.io/moocore/r/reference/HybridGA.html","id":null,"dir":"Reference","previous_headings":"","what":"Results of Hybrid GA on Vanzyl and Richmond water networks — HybridGA","title":"Results of Hybrid GA on Vanzyl and Richmond water networks — HybridGA","text":"Results Hybrid GA Vanzyl Richmond water networks","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/HybridGA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Results of Hybrid GA on Vanzyl and Richmond water networks — HybridGA","text":"","code":"HybridGA"},{"path":"https://multi-objective.github.io/moocore/r/reference/HybridGA.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Results of Hybrid GA on Vanzyl and Richmond water networks — HybridGA","text":"list two data frames, three columns, produced read_datasets(). $vanzyl data frame results Vanzyl network $richmond data frame results Richmond network. second column filled NA","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/HybridGA.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Results of Hybrid GA on Vanzyl and Richmond water networks — HybridGA","text":"Manuel López-Ibáñez (2009). Operational Optimisation Water Distribution Networks. Ph.D. thesis, School Engineering Built Environment, Edinburgh Napier University, UK. https://lopez-ibanez.eu/publications#LopezIbanezPhD. .","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/HybridGA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Results of Hybrid GA on Vanzyl and Richmond water networks — HybridGA","text":"","code":"data(HybridGA) print(HybridGA$vanzyl) #>       V1 V2 #> 1 347.10  4 #> 2 352.06  3 #> 3 352.15  4 #> 4 344.43  5 #> 5 344.81  4 #> 6 354.79  5 #> 7 344.74  5 print(HybridGA$richmond) #>     V1 V2 #> 1  101 NA #> 2  104 NA #> 3  100 NA #> 4   97 NA #> 5   97 NA #> 6  101 NA #> 7  101 NA #> 8   99 NA #> 9   98 NA #> 10  98 NA"},{"path":"https://multi-objective.github.io/moocore/r/reference/SPEA2minstoptimeRichmond.html","id":null,"dir":"Reference","previous_headings":"","what":"Results of SPEA2 when minimising electrical cost and maximising the minimum idle time of pumps on Richmond water network. — SPEA2minstoptimeRichmond","title":"Results of SPEA2 when minimising electrical cost and maximising the minimum idle time of pumps on Richmond water network. — SPEA2minstoptimeRichmond","text":"Results SPEA2 minimising electrical cost maximising minimum idle time pumps Richmond water network.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/SPEA2minstoptimeRichmond.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Results of SPEA2 when minimising electrical cost and maximising the minimum idle time of pumps on Richmond water network. — SPEA2minstoptimeRichmond","text":"","code":"SPEA2minstoptimeRichmond"},{"path":"https://multi-objective.github.io/moocore/r/reference/SPEA2minstoptimeRichmond.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Results of SPEA2 when minimising electrical cost and maximising the minimum idle time of pumps on Richmond water network. — SPEA2minstoptimeRichmond","text":"data frame produced read_datasets(). second column measures time seconds corresponds maximisation problem.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/SPEA2minstoptimeRichmond.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Results of SPEA2 when minimising electrical cost and maximising the minimum idle time of pumps on Richmond water network. — SPEA2minstoptimeRichmond","text":"Manuel López-Ibáñez (2009). Operational Optimisation Water Distribution Networks. Ph.D. thesis, School Engineering Built Environment, Edinburgh Napier University, UK. https://lopez-ibanez.eu/publications#LopezIbanezPhD.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/SPEA2minstoptimeRichmond.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Results of SPEA2 when minimising electrical cost and maximising the minimum idle time of pumps on Richmond water network. — SPEA2minstoptimeRichmond","text":"","code":"data(SPEA2minstoptimeRichmond) str(SPEA2minstoptimeRichmond) #> 'data.frame':\t166 obs. of  3 variables: #>  $ V1 : num  106 108 109 109 109 ... #>  $ V2 : num  357 911 3960 7560 16532 ... #>  $ set: num  1 1 1 1 1 1 1 1 1 1 ..."},{"path":"https://multi-objective.github.io/moocore/r/reference/SPEA2relativeRichmond.html","id":null,"dir":"Reference","previous_headings":"","what":"Results of SPEA2 with relative time-controlled triggers on Richmond water network. — SPEA2relativeRichmond","title":"Results of SPEA2 with relative time-controlled triggers on Richmond water network. — SPEA2relativeRichmond","text":"Results SPEA2 relative time-controlled triggers Richmond water network.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/SPEA2relativeRichmond.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Results of SPEA2 with relative time-controlled triggers on Richmond water network. — SPEA2relativeRichmond","text":"","code":"SPEA2relativeRichmond"},{"path":"https://multi-objective.github.io/moocore/r/reference/SPEA2relativeRichmond.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Results of SPEA2 with relative time-controlled triggers on Richmond water network. — SPEA2relativeRichmond","text":"data frame produced read_datasets().","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/SPEA2relativeRichmond.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Results of SPEA2 with relative time-controlled triggers on Richmond water network. — SPEA2relativeRichmond","text":"Manuel López-Ibáñez (2009). Operational Optimisation Water Distribution Networks. Ph.D. thesis, School Engineering Built Environment, Edinburgh Napier University, UK. https://lopez-ibanez.eu/publications#LopezIbanezPhD.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/SPEA2relativeRichmond.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Results of SPEA2 with relative time-controlled triggers on Richmond water network. — SPEA2relativeRichmond","text":"","code":"data(SPEA2relativeRichmond) str(SPEA2relativeRichmond) #> 'data.frame':\t91 obs. of  3 variables: #>  $ V1 : num  96.7 96.8 101.1 101.6 103.6 ... #>  $ V2 : num  15 14 13 12 11 10 9 8 16 15 ... #>  $ set: num  1 1 1 1 1 1 1 1 2 2 ..."},{"path":"https://multi-objective.github.io/moocore/r/reference/SPEA2relativeVanzyl.html","id":null,"dir":"Reference","previous_headings":"","what":"Results of SPEA2 with relative time-controlled triggers on Vanzyl's water network. — SPEA2relativeVanzyl","title":"Results of SPEA2 with relative time-controlled triggers on Vanzyl's water network. — SPEA2relativeVanzyl","text":"Results SPEA2 relative time-controlled triggers Vanzyl's water network.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/SPEA2relativeVanzyl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Results of SPEA2 with relative time-controlled triggers on Vanzyl's water network. — SPEA2relativeVanzyl","text":"","code":"SPEA2relativeVanzyl"},{"path":"https://multi-objective.github.io/moocore/r/reference/SPEA2relativeVanzyl.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Results of SPEA2 with relative time-controlled triggers on Vanzyl's water network. — SPEA2relativeVanzyl","text":"object class data.frame 107 rows 3 columns.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/SPEA2relativeVanzyl.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Results of SPEA2 with relative time-controlled triggers on Vanzyl's water network. — SPEA2relativeVanzyl","text":"Manuel López-Ibáñez (2009). Operational Optimisation Water Distribution Networks. Ph.D. thesis, School Engineering Built Environment, Edinburgh Napier University, UK. https://lopez-ibanez.eu/publications#LopezIbanezPhD.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/SPEA2relativeVanzyl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Results of SPEA2 with relative time-controlled triggers on Vanzyl's water network. — SPEA2relativeVanzyl","text":"","code":"data(SPEA2relativeVanzyl) str(SPEA2relativeVanzyl) #> 'data.frame':\t107 obs. of  3 variables: #>  $ V1 : num  325 339 366 336 375 ... #>  $ V2 : num  4 3 2 3 2 5 4 3 2 1 ... #>  $ set: num  1 1 1 2 2 3 3 3 3 3 ..."},{"path":"https://multi-objective.github.io/moocore/r/reference/Vorob.html","id":null,"dir":"Reference","previous_headings":"","what":"Vorob'ev threshold, expectation and deviation — vorob_t","title":"Vorob'ev threshold, expectation and deviation — vorob_t","text":"Compute Vorob'ev threshold, expectation deviation. Also, displaying symmetric deviation function possible.  symmetric deviation function probability given target objective space belong symmetric difference Vorob'ev expectation realization (random) attained set.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/Vorob.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vorob'ev threshold, expectation and deviation — vorob_t","text":"","code":"vorob_t(x, sets, reference, maximise = FALSE)  vorob_dev(x, sets, reference, ve = NULL, maximise = FALSE)"},{"path":"https://multi-objective.github.io/moocore/r/reference/Vorob.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vorob'ev threshold, expectation and deviation — vorob_t","text":"x matrix()|data.frame() Matrix data frame numerical values represents multiple sets points, row represents point. sets missing, last column x gives sets. sets integer() Vector indicates set point x. missing, last column x used instead. reference numeric() Reference point vector numerical values. maximise logical() Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective. ve matrix() Vorob'ev expectation, e.g., returned vorob_t().","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/Vorob.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vorob'ev threshold, expectation and deviation — vorob_t","text":"vorob_t returns list elements threshold, ve, avg_hyp (average hypervolume) vorob_dev returns Vorob'ev deviation.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/Vorob.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Vorob'ev threshold, expectation and deviation — vorob_t","text":"Let \\(\\mathcal{} = \\{A_1, \\dots, A_n\\}\\) multi-set \\(n\\) sets \\(A_i \\subset \\mathbb{R}^d\\) mutually nondominated vectors, finite (necessarily equal) cardinality.  bounded reference point \\(\\vec{r}\\) strictly dominated point set, sets can seen samples random closed set (Molchanov 2005) . Let \\(\\beta\\)-quantile subset empirical attainment function \\(\\mathcal{Q}_\\beta = \\{\\vec{z}\\\\mathbb{R}^d : \\hat{\\alpha}_{\\mathcal{}}(\\vec{z}) \\geq \\beta\\}\\). Vorob'ev expectation \\(\\beta^{*}\\)-quantile set \\(\\mathcal{Q}_{\\beta^{*}}\\) mean value hypervolume sets equal (close possible) hypervolume \\(\\mathcal{Q}_{\\beta^{*}}\\), , \\(\\text{hyp}(\\mathcal{Q}_\\beta) \\leq \\mathbb{E}[\\text{hyp}(\\mathcal{})] \\leq \\text{hyp}(\\mathcal{Q}_{\\beta^{*}})\\), \\(\\forall \\beta > \\beta^{*}\\). Thus, Vorob'ev expectation provides definition notion mean nondominated set. value \\(\\beta^{*} \\[0,1]\\) called Vorob'ev threshold. Large differences median quantile (0.5) indicate skewed distribution \\(\\mathcal{}\\). Vorob'ev deviation mean hypervolume symmetric difference Vorob'ev expectation set \\(\\mathcal{}\\), , \\(\\mathbb{E}[\\text{hyp}(\\mathcal{Q}_{\\beta^{*}} \\ominus \\mathcal{})]\\), symmetric difference defined \\(\\ominus B = (\\setminus B) \\cup (B \\setminus )\\).  Low deviation values indicate sets similar, terms location weakly dominated space, Vorob'ev expectation. background, see Binois et al. (2015); Molchanov (2005); Chevalier et al. (2013) .","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/Vorob.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Vorob'ev threshold, expectation and deviation — vorob_t","text":"Mickaël Binois, David Ginsbourger, Olivier Roustant (2015). “Quantifying uncertainty Pareto fronts Gaussian process conditional simulations.” European Journal Operational Research, 243(2), 386–394. doi:10.1016/j.ejor.2014.07.032 . Clément Chevalier, David Ginsbourger, Julien Bect, Ilya Molchanov (2013). “Estimating Quantifying Uncertainties Level Sets Using Vorob'ev Expectation Deviation Gaussian Process Models.” Dariusz Ucinski, Anthony C. Atkinson, Maciej Patan (eds.), mODa 10–Advances Model-Oriented Design Analysis, 35–43. Springer International Publishing, Heidelberg, Germany. doi:10.1007/978-3-319-00218-7_5 . Ilya Molchanov (2005). Theory Random Sets. Springer.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/Vorob.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Vorob'ev threshold, expectation and deviation — vorob_t","text":"Mickael Binois","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/Vorob.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vorob'ev threshold, expectation and deviation — vorob_t","text":"","code":"data(CPFs) res <- vorob_t(CPFs, reference = c(2, 200)) res$threshold #> [1] 44.14062 res$avg_hyp #> [1] 8943.333 # Now print Vorob'ev deviation vd <- vorob_dev(CPFs, ve = res$ve, reference = c(2, 200)) vd #> [1] 3017.13"},{"path":"https://multi-objective.github.io/moocore/r/reference/as_double_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert input to a matrix with ","title":"Convert input to a matrix with ","text":"Convert input matrix \"double\" storage mode (base::storage.mode()).","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/as_double_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert input to a matrix with ","text":"","code":"as_double_matrix(x)"},{"path":"https://multi-objective.github.io/moocore/r/reference/as_double_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert input to a matrix with ","text":"x data.frame()|matrix() numerical data frame matrix least 1 row 2 columns.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/as_double_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert input to a matrix with ","text":"x coerced numerical matrix().","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/attsurf2df.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert a list of attainment surfaces to a single EAF data.frame. — attsurf2df","title":"Convert a list of attainment surfaces to a single EAF data.frame. — attsurf2df","text":"Convert list attainment surfaces single EAF data.frame.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/attsurf2df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert a list of attainment surfaces to a single EAF data.frame. — attsurf2df","text":"","code":"attsurf2df(x)"},{"path":"https://multi-objective.github.io/moocore/r/reference/attsurf2df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert a list of attainment surfaces to a single EAF data.frame. — attsurf2df","text":"x list() List data.frames matrices. names list give percentiles attainment surfaces.  format returned eaf_as_list().","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/attsurf2df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert a list of attainment surfaces to a single EAF data.frame. — attsurf2df","text":"data.frame() Data frame many columns objectives additional column percentiles.","code":""},{"path":[]},{"path":"https://multi-objective.github.io/moocore/r/reference/attsurf2df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert a list of attainment surfaces to a single EAF data.frame. — attsurf2df","text":"","code":"data(SPEA2relativeRichmond) attsurfs <- eaf_as_list(eaf(SPEA2relativeRichmond, percentiles = c(0,50,100))) str(attsurfs) #> List of 3 #>  $ 0  : num [1:7, 1:2] 90 90.3 91.9 93.1 98 ... #>  $ 50 : num [1:7, 1:2] 95.1 95.2 97.2 98.2 103.2 ... #>  $ 100: num [1:5, 1:2] 100 101 102 104 112 ... eaf_df <- attsurf2df(attsurfs) str(eaf_df) #>  num [1:19, 1:3] 90 90.3 91.9 93.1 98 ... #>  - attr(*, \"dimnames\")=List of 2 #>   ..$ : NULL #>   ..$ : chr [1:3] \"\" \"\" \"percentiles\""},{"path":"https://multi-objective.github.io/moocore/r/reference/choose_eafdiff.html","id":null,"dir":"Reference","previous_headings":"","what":"Interactively choose according to empirical attainment function differences — choose_eafdiff","title":"Interactively choose according to empirical attainment function differences — choose_eafdiff","text":"Interactively choose according empirical attainment function differences","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/choose_eafdiff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Interactively choose according to empirical attainment function differences — choose_eafdiff","text":"","code":"choose_eafdiff(x, left = stop(\"'left' must be either TRUE or FALSE\"))"},{"path":"https://multi-objective.github.io/moocore/r/reference/choose_eafdiff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Interactively choose according to empirical attainment function differences — choose_eafdiff","text":"x matrix() Matrix rectangles representing EAF differences returned eafdiff() rectangles=TRUE. left logical(1) left=TRUE return rectangles positive differences, otherwise return negative differences differences converted positive.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/choose_eafdiff.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Interactively choose according to empirical attainment function differences — choose_eafdiff","text":"matrix() first 4 columns give coordinates two corners rectangle last column. cases, last column gives positive differences favor chosen side.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/choose_eafdiff.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Interactively choose according to empirical attainment function differences — choose_eafdiff","text":"","code":"# \\donttest{ extdata_dir <- system.file(package=\"moocore\", \"extdata\") A1 <- read_datasets(file.path(extdata_dir, \"wrots_l100w10_dat\")) A2 <- read_datasets(file.path(extdata_dir, \"wrots_l10w100_dat\")) # Choose A1 rectangles <- eafdiff(A1, A2, intervals = 5, rectangles = TRUE) rectangles <- choose_eafdiff(rectangles, left = TRUE) reference <- c(max(A1[, 1], A2[, 1]), max(A1[, 2], A2[, 2])) x <- split.data.frame(A1[,1:2], A1[,3]) hv_A1 <- sapply(split.data.frame(A1[, 1:2], A1[, 3]),                  hypervolume, reference=reference) hv_A2 <- sapply(split.data.frame(A2[, 1:2], A2[, 3]),                  hypervolume, reference=reference) print(fivenum(hv_A1)) #>           41           67            5           89           86  #> 785206811240 798074793438 802769574696 810246464630 827967721404  print(fivenum(hv_A2)) #>           29           46           24           74           70  #> 814132427856 820458749530 823618555606 826673145848 836333173304  whv_A1 <- sapply(split.data.frame(A1[, 1:2], A1[, 3]),                  whv_rect, rectangles=rectangles, reference=reference) whv_A2 <- sapply(split.data.frame(A2[, 1:2], A2[, 3]),                  whv_rect, rectangles=rectangles, reference=reference) print(fivenum(whv_A1)) #>          58           9          78           4          16  #>  1891625587  6232795880  8278480355  9995743574 15230375078  print(fivenum(whv_A2)) #>          84          20          65           5          10  #>   906264527  2827084909  4651576336  6792802423 11748787068  # }"},{"path":"https://multi-objective.github.io/moocore/r/reference/compute_eaf_call.html","id":null,"dir":"Reference","previous_headings":"","what":"Same as eaf() but performs no checks and does not transform the input or the output. This function should be used by other packages that want to avoid redundant checks and transformations. — compute_eaf_call","title":"Same as eaf() but performs no checks and does not transform the input or the output. This function should be used by other packages that want to avoid redundant checks and transformations. — compute_eaf_call","text":"eaf() performs checks transform input output. function used packages want avoid redundant checks transformations.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/compute_eaf_call.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Same as eaf() but performs no checks and does not transform the input or the output. This function should be used by other packages that want to avoid redundant checks and transformations. — compute_eaf_call","text":"","code":"compute_eaf_call(x, cumsizes, percentiles)"},{"path":"https://multi-objective.github.io/moocore/r/reference/compute_eaf_call.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Same as eaf() but performs no checks and does not transform the input or the output. This function should be used by other packages that want to avoid redundant checks and transformations. — compute_eaf_call","text":"x matrix()|data.frame() Matrix data frame numerical values represents multiple sets points, row represents point. sets missing, last column x gives sets. cumsizes integer() Cumulative size different sets points x. percentiles numeric() Vector indicating percentiles computed.  NULL computes .","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/compute_eaf_call.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Same as eaf() but performs no checks and does not transform the input or the output. This function should be used by other packages that want to avoid redundant checks and transformations. — compute_eaf_call","text":"data.frame() data frame containing exact representation EAF. last column gives percentile corresponds point. groups NULL, additional column indicates group point belongs.","code":""},{"path":[]},{"path":"https://multi-objective.github.io/moocore/r/reference/compute_eafdiff_call.html","id":null,"dir":"Reference","previous_headings":"","what":"Same as eafdiff() but performs no checks and does not transform the input or the output. This function should be used by other packages that want to avoid redundant checks and transformations. — compute_eafdiff_call","title":"Same as eafdiff() but performs no checks and does not transform the input or the output. This function should be used by other packages that want to avoid redundant checks and transformations. — compute_eafdiff_call","text":"eafdiff() performs checks transform input output. function used packages want avoid redundant checks transformations.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/compute_eafdiff_call.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Same as eafdiff() but performs no checks and does not transform the input or the output. This function should be used by other packages that want to avoid redundant checks and transformations. — compute_eafdiff_call","text":"","code":"compute_eafdiff_call(x, y, cumsizes_x, cumsizes_y, intervals, ret)"},{"path":"https://multi-objective.github.io/moocore/r/reference/compute_eafdiff_call.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Same as eafdiff() but performs no checks and does not transform the input or the output. This function should be used by other packages that want to avoid redundant checks and transformations. — compute_eafdiff_call","text":"x, y matrix|data.frame() Data frames corresponding input data left right sides, respectively. data frame least three columns, last one set point. See also read_datasets(). cumsizes_x, cumsizes_y Cumulative size different sets points x y. intervals integer(1) absolute range differences \\([0, 1]\\) partitioned number intervals provided. ret (\"points\"|\"rectangles\"|\"polygons\") format returned EAF differences.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/compute_eafdiff_call.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Same as eafdiff() but performs no checks and does not transform the input or the output. This function should be used by other packages that want to avoid redundant checks and transformations. — compute_eafdiff_call","text":"rectangle=FALSE, data.frame containing points transition value EAF differences.  rectangle=TRUE, matrix first 4 columns give coordinates two corners rectangle. cases, last column gives difference terms sets x minus sets y attain point (.e., negative values differences favour y).","code":""},{"path":[]},{"path":"https://multi-objective.github.io/moocore/r/reference/eaf.html","id":null,"dir":"Reference","previous_headings":"","what":"Exact computation of the Empirical Attainment Function (EAF) — eaf","title":"Exact computation of the Empirical Attainment Function (EAF) — eaf","text":"function computes EAF given set 2D 3D points vector set indicates set point belongs.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/eaf.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exact computation of the Empirical Attainment Function (EAF) — eaf","text":"","code":"eaf(x, sets, percentiles = NULL, maximise = FALSE, groups = NULL)"},{"path":"https://multi-objective.github.io/moocore/r/reference/eaf.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exact computation of the Empirical Attainment Function (EAF) — eaf","text":"x matrix()|data.frame() Matrix data frame numerical values represents multiple sets points, row represents point. sets missing, last column x gives sets. sets integer() Vector indicates set point x. missing, last column x used instead. percentiles numeric() Vector indicating percentiles computed.  NULL computes . maximise logical() Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective. groups factor() Indicates EAF must computed separately data belonging different groups.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/eaf.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exact computation of the Empirical Attainment Function (EAF) — eaf","text":"data.frame() data frame containing exact representation EAF. last column gives percentile corresponds point. groups NULL, additional column indicates group point belongs.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/eaf.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Exact computation of the Empirical Attainment Function (EAF) — eaf","text":"empirical first-order attainment function (EAF) used assess performance stochastic multiobjective optimisers multiobjective evolutionary algorithms (Grunert da Fonseca et al. 2001) .  estimator first-order attainment function, provides information location , extent, variability random sets nondominated objective vectors produced optimisers applied given problem instances. Given set \\(\\subset \\mathbb{R}^d\\), attainment function \\(\\), denoted \\(\\alpha_{}\\colon \\mathbb{R}^d\\\\{0,1\\}\\), specifies points objective space weakly dominated \\(\\), \\(\\alpha_A(\\vec{z}) = 1\\) \\(\\exists \\vec{} \\, \\vec{} \\leq \\vec{z}\\), \\(\\alpha_A(\\vec{z}) = 0\\), otherwise. Let \\(\\mathcal{} = \\{A_1, \\dots, A_n\\}\\) multi-set \\(n\\) sets \\(A_i \\subset \\mathbb{R}^d\\), EAF (Grunert da Fonseca et al. 2001; Grunert da Fonseca Fonseca 2010)  function \\(\\hat{\\alpha}_{\\mathcal{}}\\colon \\mathbb{R}^d\\[0,1]\\), : $$\\hat{\\alpha}_{\\mathcal{}}(\\vec{z}) = \\frac{1}{n}\\sum_{=1}^n \\alpha_{A_i}(\\vec{z})$$ EAF coordinate-wise non-decreasing step function, similar empirical cumulative distribution function (ECDF) (López-Ibáñez et al. 2025) .  Thus, finite representation EAF can computed set minima, terms Pareto optimality, value EAF smaller given \\(t/n\\), \\(t=1,\\dots,n\\) (Fonseca et al. 2011) . Formally, EAF can represented sequence \\((L_1, L_2, \\dots, L_n)\\), : $$L_t = \\min \\{\\vec{z} \\\\mathbb{R}^d : \\hat{\\alpha}_{\\mathcal{}}(\\vec{z}) \\geq t/n\\}$$ also common refer \\(k\\% \\[0,100]\\) percentile. example, median (50%) attainment surface corresponds \\(L_{\\lceil n/2 \\rceil}\\) lower boundary vector space attained least 50% input sets \\(A_i\\). Similarly, \\(L_1\\) called best attainment surface (\\(\\frac{1}{n}\\)%) represents lower boundary space attained least one input set, whereas \\(L_{100}\\) called worst attainment surface (100%) represents lower boundary space attained input sets. current implementation, EAF computed using algorithms proposed Fonseca et al. (2011) , complexity \\(\\Theta(m\\log m + nm)\\) 2D \\(O(n^2 m \\log m)\\) 3D, \\(n\\) number input sets \\(m\\) total number input points.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/eaf.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Exact computation of the Empirical Attainment Function (EAF) — eaf","text":"several examples data sets system.file(package=\"moocore\",\"extdata\").  current implementation supports two three dimensional points.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/eaf.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Exact computation of the Empirical Attainment Function (EAF) — eaf","text":"Carlos M. Fonseca, Andreia P. Guerreiro, Manuel López-Ibáñez, Luís Paquete (2011). “Computation Empirical Attainment Function.” R H C Takahashi, Kalyanmoy Deb, Elizabeth F. Wanner, Salvatore Greco (eds.), Evolutionary Multi-criterion Optimization, EMO 2011, volume 6576 Lecture Notes Computer Science, 106–120. Springer, Berlin~/ Heidelberg. doi:10.1007/978-3-642-19893-9_8 . Viviane Grunert da Fonseca, Carlos M. Fonseca (2010). “Attainment-Function Approach Stochastic Multiobjective Optimizer Assessment Comparison.” Thomas Bartz-Beielstein, Marco Chiarandini, Luís Paquete, Mike Preuss (eds.), Experimental Methods Analysis Optimization Algorithms, 103–130. Springer, Berlin~/ Heidelberg. doi:10.1007/978-3-642-02538-9_5 . Viviane Grunert da Fonseca, Carlos M. Fonseca, Andreia O. Hall (2001). “Inferential Performance Assessment Stochastic Optimisers Attainment Function.” Eckart Zitzler, Kalyanmoy Deb, Lothar Thiele, Carlos . Coello Coello, David Corne (eds.), Evolutionary Multi-criterion Optimization, EMO 2001, volume 1993 Lecture Notes Computer Science, 213–225. Springer, Berlin~/ Heidelberg. doi:10.1007/3-540-44719-9_15 . Manuel López-Ibáñez, Diederick Vermetten, Johann Dreo, Carola Doerr (2025). “Using Empirical Attainment Function Analyzing Single-objective Black-box Optimization Algorithms.” IEEE Transactions Evolutionary Computation, 29(5), 1774–1782. doi:10.1109/TEVC.2024.3462758 .","code":""},{"path":[]},{"path":"https://multi-objective.github.io/moocore/r/reference/eaf.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Exact computation of the Empirical Attainment Function (EAF) — eaf","text":"Manuel López-Ibáñez","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/eaf.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Exact computation of the Empirical Attainment Function (EAF) — eaf","text":"","code":"extdata_path <- system.file(package=\"moocore\", \"extdata\")  x <- read_datasets(file.path(extdata_path, \"example1_dat\")) # Compute full EAF (sets is the last column) str(eaf(x)) #>  num [1:215, 1:3] 5128176 5134240 5142568 5144532 5155408 ...  # Compute only best, median and worst str(eaf(x[,1:2], sets = x[,3], percentiles = c(0, 50, 100))) #>  num [1:50, 1:3] 5128176 5134240 5142568 5144532 5155408 ...  x <- read_datasets(file.path(extdata_path, \"spherical-250-10-3d.txt\")) y <- read_datasets(file.path(extdata_path, \"uniform-250-10-3d.txt\")) x <- rbind(data.frame(x, groups = \"spherical\"),            data.frame(y, groups = \"uniform\")) # Compute only median separately for each group z <- eaf(x[,1:3], sets = x[,4], groups = x[,5], percentiles = 50) str(z) #> 'data.frame':\t12650 obs. of  5 variables: #>  $ X1    : num  0.865 0.787 0.682 0.739 0.865 ... #>  $ X2    : num  0.966 0.966 0.997 0.966 0.926 ... #>  $ X3    : num  0.00264 0.00421 0.00483 0.00449 0.00421 ... #>  $ X4    : num  50 50 50 50 50 50 50 50 50 50 ... #>  $ groups: chr  \"spherical\" \"spherical\" \"spherical\" \"spherical\" ..."},{"path":"https://multi-objective.github.io/moocore/r/reference/eaf_as_list.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert an EAF data frame to a list of data frames, where each element of the list is one attainment surface. The function attsurf2df() can be used to convert the list into a single data frame. — eaf_as_list","title":"Convert an EAF data frame to a list of data frames, where each element of the list is one attainment surface. The function attsurf2df() can be used to convert the list into a single data frame. — eaf_as_list","text":"Convert EAF data frame list data frames, element list one attainment surface. function attsurf2df() can used convert list single data frame.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/eaf_as_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert an EAF data frame to a list of data frames, where each element of the list is one attainment surface. The function attsurf2df() can be used to convert the list into a single data frame. — eaf_as_list","text":"","code":"eaf_as_list(eaf)"},{"path":"https://multi-objective.github.io/moocore/r/reference/eaf_as_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert an EAF data frame to a list of data frames, where each element of the list is one attainment surface. The function attsurf2df() can be used to convert the list into a single data frame. — eaf_as_list","text":"eaf data.frame()|matrix() Data frame matrix represents EAF.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/eaf_as_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert an EAF data frame to a list of data frames, where each element of the list is one attainment surface. The function attsurf2df() can be used to convert the list into a single data frame. — eaf_as_list","text":"list() list data frames. data.frame represents one attainment surface.","code":""},{"path":[]},{"path":"https://multi-objective.github.io/moocore/r/reference/eaf_as_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert an EAF data frame to a list of data frames, where each element of the list is one attainment surface. The function attsurf2df() can be used to convert the list into a single data frame. — eaf_as_list","text":"","code":"extdata_path <- system.file(package=\"moocore\", \"extdata\") x <- read_datasets(file.path(extdata_path, \"example1_dat\")) attsurfs <- eaf_as_list(eaf(x, percentiles = c(0, 50, 100))) str(attsurfs) #> List of 3 #>  $ 0  : num [1:9, 1:2] 5128176 5134240 5142568 5144532 5155408 ... #>  $ 50 : num [1:25, 1:2] 5135414 5136906 5137952 5143188 5146024 ... #>  $ 100: num [1:16, 1:2] 5153534 5155512 5155716 5158466 5160938 ..."},{"path":"https://multi-objective.github.io/moocore/r/reference/eafdiff.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute empirical attainment function differences — eafdiff","title":"Compute empirical attainment function differences — eafdiff","text":"Calculate differences empirical attainment functions two data sets.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/eafdiff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute empirical attainment function differences — eafdiff","text":"","code":"eafdiff(x, y, intervals = NULL, maximise = FALSE, rectangles = FALSE)"},{"path":"https://multi-objective.github.io/moocore/r/reference/eafdiff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute empirical attainment function differences — eafdiff","text":"x, y matrix|data.frame() Data frames corresponding input data left right sides, respectively. data frame least three columns, last one set point. See also read_datasets(). intervals integer(1) absolute range differences \\([0, 1]\\) partitioned number intervals provided. maximise logical() Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective. rectangles logical(1) TRUE, output form rectangles color.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/eafdiff.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute empirical attainment function differences — eafdiff","text":"rectangle=FALSE, data.frame containing points transition value EAF differences.  rectangle=TRUE, matrix first 4 columns give coordinates two corners rectangle. cases, last column gives difference terms sets x minus sets y attain point (.e., negative values differences favour y).","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/eafdiff.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute empirical attainment function differences — eafdiff","text":"function calculates differences EAFs two data sets.","code":""},{"path":[]},{"path":"https://multi-objective.github.io/moocore/r/reference/eafdiff.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute empirical attainment function differences — eafdiff","text":"","code":"A1 <- read_datasets(text='  3 2  2 3   2.5 1  1 2   1 2 ')  A2 <- read_datasets(text='  4 2.5  3 3  2.5 3.5   3 3  2.5 3.5   2 1 ') d <- eafdiff(A1, A2) str(d) #>  num [1:9, 1:3] 1 2 2.5 2 2 3 2.5 3 4 2 ... d #>       [,1] [,2] [,3] #>  [1,]  1.0  2.0    2 #>  [2,]  2.0  1.0   -1 #>  [3,]  2.5  1.0    0 #>  [4,]  2.0  2.0    1 #>  [5,]  2.0  3.0    2 #>  [6,]  3.0  2.0    2 #>  [7,]  2.5  3.5    0 #>  [8,]  3.0  3.0    0 #>  [9,]  4.0  2.5    1          d <- eafdiff(A1, A2, rectangles = TRUE) str(d) #>  num [1:9, 1:5] 2 1 2.5 2 2 2 3 3 4 1 ... #>  - attr(*, \"dimnames\")=List of 2 #>   ..$ : NULL #>   ..$ : chr [1:5] \"xmin\" \"ymin\" \"xmax\" \"ymax\" ... d #>       xmin ymin xmax ymax diff #>  [1,]  2.0  1.0  2.5  2.0   -1 #>  [2,]  1.0  2.0  2.0  Inf    2 #>  [3,]  2.5  1.0  Inf  2.0    0 #>  [4,]  2.0  2.0  3.0  3.0    1 #>  [5,]  2.0  3.5  2.5  Inf    2 #>  [6,]  2.0  3.0  3.0  3.5    2 #>  [7,]  3.0  2.5  4.0  3.0    2 #>  [8,]  3.0  2.0  Inf  2.5    2 #>  [9,]  4.0  2.5  Inf  3.0    1"},{"path":"https://multi-objective.github.io/moocore/r/reference/epsilon.html","id":null,"dir":"Reference","previous_headings":"","what":"Epsilon metric — epsilon","title":"Epsilon metric — epsilon","text":"Computes epsilon metric, either additive multiplicative.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/epsilon.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Epsilon metric — epsilon","text":"","code":"epsilon_additive(x, reference, maximise = FALSE)  epsilon_mult(x, reference, maximise = FALSE)"},{"path":"https://multi-objective.github.io/moocore/r/reference/epsilon.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Epsilon metric — epsilon","text":"x matrix()|data.frame() Matrix data frame numerical values, row gives coordinates point. reference matrix|data.frame Reference set matrix data.frame numerical values. maximise logical() Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/epsilon.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Epsilon metric — epsilon","text":"numeric(1) single numerical value.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/epsilon.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Epsilon metric — epsilon","text":"epsilon metric set \\(\\subset \\mathbb{R}^m\\) respect reference set \\(R \\subset \\mathbb{R}^m\\) defined $$epsilon(,R) = \\max_{r \\R} \\min_{\\} \\max_{1 \\leq \\leq m} epsilon(a_i, r_i)$$ \\(\\) \\(r\\) objective vectors length \\(m\\). case minimization objective \\(\\), \\(epsilon(a_i,r_i)\\) computed \\(a_i/r_i\\) multiplicative variant (respectively, \\(a_i - r_i\\) additive variant), whereas case maximization objective \\(\\), \\(epsilon(a_i,r_i) = r_i/a_i\\) multiplicative variant (respectively, \\(r_i - a_i\\) additive variant). allows computing single value problems objectives maximized others minimized. Moreover, lower value corresponds better approximation set, independently type problem (minimization, maximization mixed). However, meaning value different objective type. example, imagine objective 1 minimized objective 2 maximized, multiplicative epsilon computed \\(epsilon(,R) = 3\\). means \\(\\) needs multiplied 1/3 \\(a_1\\) values 3 \\(a_2\\) values order weakly dominate \\(R\\). multiplicative variant can computed \\(\\exp(epsilon_{+}(\\log(), \\log(R)))\\), makes clear computation multiplicative version zero negative values make sense. See examples . current implementation uses naive algorithm requires \\(O(m \\cdot || \\cdot |R|)\\), \\(m\\) number objectives (dimension vectors).","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/epsilon.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Epsilon metric — epsilon","text":"Eckart Zitzler, Lothar Thiele, Marco Laumanns, Carlos M. Fonseca, Viviane Grunert da Fonseca (2003). “Performance Assessment Multiobjective Optimizers: Analysis Review.” IEEE Transactions Evolutionary Computation, 7(2), 117–132. doi:10.1109/TEVC.2003.810758 .","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/epsilon.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Epsilon metric — epsilon","text":"Manuel López-Ibáñez","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/epsilon.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Epsilon metric — epsilon","text":"","code":"# Fig 6 from Zitzler et al. (2003). A1 <- matrix(c(9,2,8,4,7,5,5,6,4,7), ncol=2, byrow=TRUE) A2 <- matrix(c(8,4,7,5,5,6,4,7), ncol=2, byrow=TRUE) A3 <- matrix(c(10,4,9,5,8,6,7,7,6,8), ncol=2, byrow=TRUE) if (requireNamespace(\"graphics\", quietly = TRUE)) {    plot(A1, xlab=expression(f[1]), ylab=expression(f[2]),         panel.first=grid(nx=NULL), pch=4, cex=1.5, xlim = c(0,10), ylim=c(0,8))    points(A2, pch=0, cex=1.5)    points(A3, pch=1, cex=1.5)    legend(\"bottomleft\", legend=c(\"A1\", \"A2\", \"A3\"), pch=c(4,0,1),           pt.bg=\"gray\", bg=\"white\", bty = \"n\", pt.cex=1.5, cex=1.2) }  epsilon_mult(A1, A3) # A1 epsilon-dominates A3 => e = 9/10 < 1 #> [1] 0.9 epsilon_mult(A1, A2) # A1 weakly dominates A2 => e = 1 #> [1] 1 epsilon_mult(A2, A1) # A2 is epsilon-dominated by A1 => e = 2 > 1 #> [1] 2 # Equivalence between additive and multiplicative exp(epsilon_additive(log(A2), log(A1))) #> [1] 2  # A more realistic example extdata_path <- system.file(package=\"moocore\",\"extdata\") path.A1 <- file.path(extdata_path, \"ALG_1_dat.xz\") path.A2 <- file.path(extdata_path, \"ALG_2_dat.xz\") A1 <- read_datasets(path.A1)[,1:2] A2 <- read_datasets(path.A2)[,1:2] ref <- filter_dominated(rbind(A1, A2)) epsilon_additive(A1, ref) #> [1] 199090640 epsilon_additive(A2, ref) #> [1] 132492066 # Multiplicative version of epsilon metric ref <- filter_dominated(rbind(A1, A2)) epsilon_mult(A1, ref) #> [1] 1.054015 epsilon_mult(A2, ref) #> [1] 1.023755"},{"path":"https://multi-objective.github.io/moocore/r/reference/generate_ndset.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate a random set of mutually nondominated points — generate_ndset","title":"Generate a random set of mutually nondominated points — generate_ndset","text":"Generate random set n mutually nondominated points dimension d shape defined method. integer = FALSE (default), points generated within hypercube \\((0,1)^d\\) can scaled another range using normalise().  Otherwise, points scaled non-negative integer range keeps points mutually nondominated. See visualisations vignette Sampling Random Nondominated Sets.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/generate_ndset.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate a random set of mutually nondominated points — generate_ndset","text":"","code":"generate_ndset(n, d, method, seed = NULL, integer = FALSE)"},{"path":"https://multi-objective.github.io/moocore/r/reference/generate_ndset.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate a random set of mutually nondominated points — generate_ndset","text":"n integer(1) Number rows output. d integer(1) Number columns output. method character(1) Method used generate random nondominated set. See Details information. seed integer(1) Integer seed random number generation. NULL, random seed generated. integer logical(1) TRUE, return integer-valued points.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/generate_ndset.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate a random set of mutually nondominated points — generate_ndset","text":"numeric matrix size n × d containing nondominated points.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/generate_ndset.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate a random set of mutually nondominated points — generate_ndset","text":"available methods : \"simplex\", \"linear\", \"L\": Uniformly samples points standard simplex. \"concave-sphere\", \"sphere\", \"C\": Uniformly samples points positive orthant unit hypersphere (concave minimisation). \"convex-sphere\" \"X\": Equivalent 1 - generate_ndset(..., method=\"concave-sphere\"), convex minimisation. \"convex-simplex\": Equivalent generate_ndset(..., method=\"concave-sphere\")^4, convex minimisation. set obtained affine transformation subset hyper-sphere. Method \"simplex\" uniformly samples points standard \\((d-1)\\)-simplex defined \\(\\{x \\R_+^d : \\sum_i x_i = 1\\}\\). shape nondominated set also called \"linear\" literature (Lacour et al. 2017) .  point \\(\\vec{z} \\(0,1)^d \\subset \\mathbb{R}^d\\) generated sampling \\(d\\) independent identically distributed values \\((x_1,x_2, \\dots, x_d)\\) exponential distribution, dividing value L1-norm vector, \\(z_i = x_i / \\sum_{=1}^d x_i\\) (Rubinstein Melamed 1998) .  Values sampled exponential distribution guaranteed positive. Sampling either standard normal distribution (Guerreiro et al. 2021)  uniform distribution (Lacour et al. 2017)  produce uniform distribution projected simplex. Method \"concave-sphere\" uniformly samples points positive orthant hyper-sphere, concave objectives minimised. point \\(\\vec{z} \\(0,1)^d \\subset \\mathbb{R}^d\\) generated sampling \\(d\\) independent identically distributed values \\(\\vec{x}=(x_1,x_2, \\dots, x_d)\\) standard normal distribution, dividing value l2-norm vector, \\(z_i = \\frac{|x_i|}{\\|\\vec{x}\\|_2}\\) (Muller 1959) . absolute value numerator ensures points sampled positive orthant hyper-sphere.  Sampling uniform distribution (Lacour et al. 2017)  result uniform sampling projected onto surface hyper-sphere. Method \"convex-sphere\" equivalent 1 - generate_ndset(..., method=\"concave-sphere\"), convex minimisation problems.  corresponds translating points negative orthant hyper-sphere positive orthant. Method \"convex-simplex\" equivalent generate_ndset(..., method=\"concave-sphere\")^4, convex minimisation problems. corresponding surface equivalent simplex curved towards origin.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/generate_ndset.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Generate a random set of mutually nondominated points — generate_ndset","text":"Andreia P. Guerreiro, Carlos M. Fonseca, Luís Paquete (2021). “Hypervolume Indicator: Computational Problems Algorithms.” ACM Computing Surveys, 54(6), 1–42. doi:10.1145/3453474 . Renaud Lacour, Kathrin Klamroth, Carlos M. Fonseca (2017). “box decomposition algorithm compute hypervolume indicator.” Computers & Operations Research, 79, 347–360. doi:10.1016/J.COR.2016.06.021 . Mervin E. Muller (1959). “Note Method Generating Points Uniformly N-Dimensional Spheres.” Communications ACM, 2(4), 19–20. doi:10.1145/377939.377946 . R Y Rubinstein, B Melamed (1998). Modern simulation modeling. Wiley, New York, NY. Uniform sampling simplex.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/generate_ndset.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate a random set of mutually nondominated points — generate_ndset","text":"","code":"generate_ndset(5, 3, \"simplex\", seed = 42) #>            [,1]       [,2]       [,3] #> [1,] 0.06596540 0.48679186 0.44724274 #> [2,] 0.19532517 0.09279699 0.71187784 #> [3,] 0.35895521 0.51930440 0.12174039 #> [4,] 0.02967672 0.92592202 0.04440126 #> [5,] 0.19376601 0.29273646 0.51349753 generate_ndset(5, 3, \"simplex\", seed = 42, integer = TRUE) #>      [,1] [,2] [,3] #> [1,]    4   31   28 #> [2,]   12    5   45 #> [3,]   22   33    7 #> [4,]    1   59    2 #> [5,]   12   18   32 generate_ndset(4, 2, \"sphere\", seed = 123) #>            [,1]      [,2] #> [1,] 0.97441130 0.2247724 #> [2,] 0.13301659 0.9911138 #> [3,] 0.95895269 0.2835661 #> [4,] 0.05564879 0.9984504 generate_ndset(3, 5, \"convex-sphere\", seed = 123) #>           [,1]      [,2]      [,3]      [,4]      [,5] #> [1,] 0.4061573 0.9252940 0.5116439 0.5278063 0.5753693 #> [2,] 0.8709372 0.9275071 0.2906674 0.3136450 0.9379391 #> [3,] 0.3780677 0.3156806 0.7259423 0.8564325 0.7782166 generate_ndset(4, 4, \"convex-simplex\", seed = 123) #>              [,1]         [,2]         [,3]         [,4] #> [1,] 1.063566e-01 0.0003011388 0.2398790054 2.780510e-02 #> [2,] 2.732218e-04 0.8421439916 0.0038396031 1.460775e-05 #> [3,] 2.981715e-01 0.0022797886 0.1134092373 4.821802e-03 #> [4,] 1.017756e-06 0.1054694460 0.0006902269 4.198501e-01"},{"path":"https://multi-objective.github.io/moocore/r/reference/hv_approx.html","id":null,"dir":"Reference","previous_headings":"","what":"Approximate the hypervolume indicator. — hv_approx","title":"Approximate the hypervolume indicator. — hv_approx","text":"Approximate value hypervolume metric respect given reference point assuming minimization objectives. default method=\"DZ2019-HW\" deterministic ignores parameter seed, method=\"DZ2019-MC\" relies Monte-Carlo sampling (Deng Zhang 2019) .  methods tend get accurate higher values nsamples, increase accuracy monotonic, shown vignette Approximating hypervolume.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/hv_approx.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Approximate the hypervolume indicator. — hv_approx","text":"","code":"hv_approx(   x,   reference,   maximise = FALSE,   nsamples = 100000L,   seed = NULL,   method = c(\"DZ2019-HW\", \"DZ2019-MC\") )"},{"path":"https://multi-objective.github.io/moocore/r/reference/hv_approx.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Approximate the hypervolume indicator. — hv_approx","text":"x matrix()|data.frame() Matrix data frame numerical values, row gives coordinates point. reference numeric() Reference point vector numerical values. maximise logical() Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective. nsamples integer(1) Number samples Monte-Carlo sampling. seed integer(1) Random seed. method character(1) Method generate sampling weights. See `Details'.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/hv_approx.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Approximate the hypervolume indicator. — hv_approx","text":"single numerical value.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/hv_approx.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Approximate the hypervolume indicator. — hv_approx","text":"function implements method proposed Deng Zhang (2019)  approximate hypervolume: $$\\widehat{HV}_r() = \\frac{2\\pi^\\frac{m}{2}}{\\Gamma(\\frac{m}{2})}\\frac{1}{m 2^m}\\frac{1}{n}\\sum_{=1}^n \\max_{y \\} s(w^{()}, y)^m$$ \\(m\\) number objectives, \\(n\\) number weights \\(w^{()}\\) sampled, \\(\\Gamma()\\) gamma function gamma(), .e., analytical continuation factorial function, \\(s(w, y) = \\min_{k=1}^m (r_k - y_k)/w_k\\). default method=\"DZ2019-HW\", weights \\(w^{()}, =1\\ldots n\\) defined using deterministic low-discrepancy sequence. weight values depend number (nsamples), thus increasing number weights may necessarily increase accuracy set weights different. method=\"DZ2019-MC\", weights \\(w^{()}, =1\\ldots n\\) sampled unit normal vector weight \\(w = \\frac{|x|}{\\|x\\|_2}\\) component \\(x\\) independently sampled standard normal distribution.  original source code C++/MATLAB methods can found https://github.com/Ksrma/Hypervolume-Approximation-using-polar-coordinate.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/hv_approx.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Approximate the hypervolume indicator. — hv_approx","text":"Jingda Deng, Qingfu Zhang (2019). “Approximating Hypervolume Hypervolume Contributions Using Polar Coordinate.” IEEE Transactions Evolutionary Computation, 23(5), 913–918. doi:10.1109/tevc.2019.2895108 .","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/hv_approx.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Approximate the hypervolume indicator. — hv_approx","text":"Manuel López-Ibáñez","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/hv_approx.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Approximate the hypervolume indicator. — hv_approx","text":"","code":"x <- matrix(c(5, 5, 4, 6, 2, 7, 7, 4), ncol=2, byrow=TRUE) hypervolume(x, ref=10) #> [1] 38 hv_approx(x, ref=10, seed=42, method=\"DZ2019-MC\") #> [1] 38.01475 hv_approx(x, ref=10, method=\"DZ2019-HW\") #> [1] 37.99989"},{"path":"https://multi-objective.github.io/moocore/r/reference/hv_contributions.html","id":null,"dir":"Reference","previous_headings":"","what":"Hypervolume contribution of a set of points — hv_contributions","title":"Hypervolume contribution of a set of points — hv_contributions","text":"Computes hypervolume contribution point set points respect given reference point. Duplicated dominated points zero contribution.  default, dominated points ignored, , affect contribution points.  See Notes details.  details hypervolume, see hypervolume().","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/hv_contributions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hypervolume contribution of a set of points — hv_contributions","text":"","code":"hv_contributions(x, reference, maximise = FALSE, ignore_dominated = TRUE)"},{"path":"https://multi-objective.github.io/moocore/r/reference/hv_contributions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hypervolume contribution of a set of points — hv_contributions","text":"x matrix()|data.frame() Matrix data frame numerical values, row gives coordinates point. reference numeric() Reference point vector numerical values. maximise logical() Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective. ignore_dominated logical(1) Whether dominated points ignored computing contribution nondominated points.  value parameter effect return values input contains dominated points. Setting FALSE slows computation significantly.  See Notes detailed explanation.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/hv_contributions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hypervolume contribution of a set of points — hv_contributions","text":"numeric() numerical vector","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/hv_contributions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hypervolume contribution of a set of points — hv_contributions","text":"hypervolume contribution point \\(\\vec{p} \\X\\) defined \\(\\text{hvc}(\\vec{p}) = \\text{hyp}(X) - \\text{hyp}(X \\setminus \\{\\vec{p}\\})\\).  definition implies duplicated points zero contribution even dominated, removing one duplicates change hypervolume remaining set.  Moreover, dominated points also zero contribution. However, point dominated single (dominating) nondominated point reduces contribution latter, removing dominating point makes dominated one become nondominated. Handling special case non-trivial makes computation expensive, thus default (ignore_dominated=TRUE) ignores dominated points input, , contribution set zero presence affect contribution point.  Setting ignore_dominated=FALSE consider dominated points according mathematical definition given , computation slower. input consists mutually nondominated points, value ignore_dominated change result, default value significantly faster. current implementation uses \\(O(n\\log n)\\) dimension-sweep algorithm 2D.  ignore_dominated=TRUE, 3D case uses HVC3D algorithm (Guerreiro Fonseca 2018) , \\(O(n\\log n)\\) complexity. Otherwise, implementation uses naive algorithm requires calculating hypervolume \\(|X|+1\\) times.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/hv_contributions.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Hypervolume contribution of a set of points — hv_contributions","text":"Andreia P. Guerreiro, Carlos M. Fonseca (2018). “Computing Updating Hypervolume Contributions Four Dimensions.” IEEE Transactions Evolutionary Computation, 22(3), 449–463. doi:10.1109/tevc.2017.2729550 .","code":""},{"path":[]},{"path":"https://multi-objective.github.io/moocore/r/reference/hv_contributions.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Hypervolume contribution of a set of points — hv_contributions","text":"Manuel López-Ibáñez","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/hv_contributions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hypervolume contribution of a set of points — hv_contributions","text":"","code":"x <- matrix(c(5,1, 1,5, 4,2, 4,4, 5,1), ncol=2, byrow=TRUE) hv_contributions(x, reference=c(6,6)) #> [1] 0 3 3 0 0 # hvc[(5,1)] = 0 = duplicated # hvc[(1,5)] = 3 = (4 - 1) * (6 - 5) # hvc[(4,2)] = 3 = (5 - 4) * (5 - 2) # hvc[(4,4)] = 0 = dominated # hvc[(5,1)] = 0 = duplicated hv_contributions(x, reference=c(6,6), ignore_dominated = FALSE) #> [1] 0 3 2 0 0 # hvc[(5,1)] = 0 = duplicated # hvc[(1,5)] = 3 = (4 - 1) * (6 - 5) # hvc[(4,2)] = 2 = (5 - 4) * (4 - 2) # hvc[(4,4)] = 0 = dominated # hvc[(5,1)] = 0 = duplicated data(SPEA2minstoptimeRichmond) # The second objective must be maximized # We calculate the hypervolume contribution of each point of the union of all sets. hv_contributions(SPEA2minstoptimeRichmond[, 1:2], reference = c(250, 0),             maximise = c(FALSE, TRUE)) #>   [1]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #>   [8]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #>  [15]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #>  [22]     0.000     8.197     0.000     0.000     0.000     0.000     0.000 #>  [29]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #>  [36]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #>  [43]     0.000     0.000     0.000     0.000     0.000     0.000  7959.940 #>  [50]  1945.800  8147.132     0.000     0.000     0.000     0.000     0.000 #>  [57]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #>  [64]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #>  [71]    26.255     0.000     0.000     0.000     0.000     0.000     0.000 #>  [78]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #>  [85]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #>  [92]     0.000  3698.640     0.000     0.000     5.971     0.000     0.000 #>  [99]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #> [106]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #> [113]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #> [120]     0.000  3069.000   779.240     0.000     0.000     0.000     0.000 #> [127]     0.000     0.000     0.000     0.000     0.000 41994.755     0.000 #> [134]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #> [141]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #> [148]     0.000     0.000     0.000     0.000     0.000     0.000     0.000 #> [155]     0.000     0.000     0.000     0.000     0.000  2294.064     0.000 #> [162]     0.000     0.000     0.000     0.000     0.000  # Duplicated points show zero contribution above, even if not # dominated. However, filter_dominated removes all duplicates except # one. Hence, there are more points below with nonzero contribution. hv_contributions(filter_dominated(SPEA2minstoptimeRichmond[, 1:2], maximise = c(FALSE, TRUE)),                  reference = c(250, 0), maximise = c(FALSE, TRUE)) #>  [1]  89283.920 255278.978      8.197   2242.660   7959.940   1945.800 #>  [7]   8147.132     73.054     26.255   3698.640      5.971 193143.324 #> [13]   3069.000    779.240  41994.755   2294.064"},{"path":"https://multi-objective.github.io/moocore/r/reference/hypervolume.html","id":null,"dir":"Reference","previous_headings":"","what":"Hypervolume metric — hypervolume","title":"Hypervolume metric — hypervolume","text":"Compute hypervolume metric respect given reference point assuming minimization objectives.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/hypervolume.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Hypervolume metric — hypervolume","text":"","code":"hypervolume(x, reference, maximise = FALSE)"},{"path":"https://multi-objective.github.io/moocore/r/reference/hypervolume.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Hypervolume metric — hypervolume","text":"x matrix()|data.frame() Matrix data frame numerical values, row gives coordinates point. reference numeric() Reference point vector numerical values. maximise logical() Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/hypervolume.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Hypervolume metric — hypervolume","text":"numeric(1) single numerical value.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/hypervolume.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Hypervolume metric — hypervolume","text":"hypervolume set multidimensional points \\(\\subset \\mathbb{R}^m\\), \\(m\\) dimension points, respect reference point \\(\\vec{r} \\\\mathbb{R}^m\\) volume region dominated set bounded reference point (Zitzler Thiele 1998) .  Points \\(\\) strictly dominate \\(\\vec{r}\\) contribute hypervolume value, thus, ideally, reference point must strictly dominated points true Pareto front. precisely, hypervolume Lebesgue measure union axis-aligned hyperrectangles (orthotopes), hyperrectangle defined one point \\(\\vec{} \\\\) reference point.  union axis-aligned hyperrectangles also called orthogonal polytope. hypervolume compatible Pareto-optimality (Knowles Corne 2002; Zitzler et al. 2003) , , \\(\\nexists ,B \\subset \\mathbb{R}^m\\), \\(\\) better \\(B\\) terms Pareto-optimality \\(\\text{hyp}() \\leq \\text{hyp}(B)\\). words, set better another terms Pareto-optimality, hypervolume former must strictly larger hypervolume latter. Conversely, hypervolume set larger hypervolume another, know sure latter set better former terms Pareto-optimality. Like measures unions high-dimensional geometric objects, computing hypervolume #P-hard (Bringmann Friedrich 2010) . 2D 3D, algorithms used (Fonseca et al. 2006; Beume et al. 2009)  \\(O(n \\log n)\\) complexity, \\(n\\) number input points. 3D case uses \\(\\text{HV3D}^{+}\\) algorithm (Guerreiro Fonseca 2018) , sample complexity HV3D algorithm (Fonseca et al. 2006; Beume et al. 2009) , faster practice. 4D, algorithm used \\(\\text{HV4D}^{+}\\) (Guerreiro Fonseca 2018) , \\(O(n^2)\\) complexity.  Compared original implementation, implementation correctly handles weakly dominated points optimized speed. 5D higher 15 points, implementation uses inclusion-exclusion algorithm (Wu Azam 2001) , \\(O(m 2^{n})\\) time \\(O(n\\cdot m)\\) space complexity, fast small sets.  larger number points, uses recursive algorithm (Fonseca et al. 2006)  computes 4D contributions (Guerreiro Fonseca 2018)  base case, resulting \\(O(n^{m-2})\\) time complexity \\(O(n)\\) space complexity worst-case. Experimental results show pruning techniques used may reduce time complexity even .  original proposal (Fonseca et al. 2006)  HV3D algorithm base case, giving time complexity \\(O(n^{m-2} \\log n)\\).  Andreia P. Guerreiro enhanced numerical stability algorithm avoiding floating-point comparisons partial hypervolumes. hypervolume 1D inputs defined max(0, ref - min(x)).","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/hypervolume.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Hypervolume metric — hypervolume","text":"Nicola Beume, Carlos M. Fonseca, Manuel López-Ibáñez, Luís Paquete, Jan Vahrenhold (2009). “complexity computing hypervolume indicator.” IEEE Transactions Evolutionary Computation, 13(5), 1075–1082. doi:10.1109/TEVC.2009.2015575 . Karl Bringmann, Tobias Friedrich (2010). “Approximating volume unions intersections high-dimensional geometric objects.” Computational Geometry, 43(6–7), 601–610. doi:10.1016/j.comgeo.2010.03.004 . Carlos M. Fonseca, Luís Paquete, Manuel López-Ibáñez (2006). “improved dimension-sweep algorithm hypervolume indicator.” Proceedings  2006 Congress Evolutionary Computation (CEC 2006), 1157–1163. doi:10.1109/CEC.2006.1688440 . Andreia P. Guerreiro, Carlos M. Fonseca (2018). “Computing Updating Hypervolume Contributions Four Dimensions.” IEEE Transactions Evolutionary Computation, 22(3), 449–463. doi:10.1109/tevc.2017.2729550 . Joshua D. Knowles, David Corne (2002). “Metrics Comparing Non-Dominated Sets.” Proceedings  2002 Congress Evolutionary Computation (CEC'02), 711–716. J Wu, S Azam (2001). “Metrics Quality Assessment Multiobjective Design Optimization Solution Set.” Journal Mechanical Design, 123(1), 18–25. doi:10.1115/1.1329875 . Eckart Zitzler, Lothar Thiele (1998). “Multiobjective Optimization Using Evolutionary Algorithms - Comparative Case Study.” Agoston E. Eiben, Thomas Bäck, Marc Schoenauer, Hans-Paul Schwefel (eds.), Parallel Problem Solving Nature – PPSN V, volume 1498 Lecture Notes Computer Science, 292–301. Springer, Heidelberg, Germany. doi:10.1007/BFb0056872 . Eckart Zitzler, Lothar Thiele, Marco Laumanns, Carlos M. Fonseca, Viviane Grunert da Fonseca (2003). “Performance Assessment Multiobjective Optimizers: Analysis Review.” IEEE Transactions Evolutionary Computation, 7(2), 117–132. doi:10.1109/TEVC.2003.810758 .","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/hypervolume.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Hypervolume metric — hypervolume","text":"Manuel López-Ibáñez","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/hypervolume.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Hypervolume metric — hypervolume","text":"","code":"dat = matrix(c(5, 5, 4, 6, 2, 7, 7, 4), ncol=2, byrow=TRUE) hypervolume(dat, ref=c(10, 10)) #> [1] 38 hypervolume(dat, ref=0, maximise=TRUE) #> [1] 39  data(SPEA2minstoptimeRichmond) # The second objective must be maximized # We calculate the hypervolume of the union of all sets. hypervolume(SPEA2minstoptimeRichmond[, 1:2], reference = c(250, 0),             maximise = c(FALSE, TRUE)) #> [1] 7911376"},{"path":"https://multi-objective.github.io/moocore/r/reference/igd.html","id":null,"dir":"Reference","previous_headings":"","what":"Inverted Generational Distance (IGD and IGD+) and Averaged Hausdorff Distance — igd","title":"Inverted Generational Distance (IGD and IGD+) and Averaged Hausdorff Distance — igd","text":"Functions compute inverted generational distance (IGD IGD+) averaged Hausdorff distance nondominated sets points.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/igd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Inverted Generational Distance (IGD and IGD+) and Averaged Hausdorff Distance — igd","text":"","code":"igd(x, reference, maximise = FALSE)  igd_plus(x, reference, maximise = FALSE)  avg_hausdorff_dist(x, reference, maximise = FALSE, p = 1L)"},{"path":"https://multi-objective.github.io/moocore/r/reference/igd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Inverted Generational Distance (IGD and IGD+) and Averaged Hausdorff Distance — igd","text":"x matrix()|data.frame() Matrix data frame numerical values, row gives coordinates point. reference matrix|data.frame Reference set matrix data.frame numerical values. maximise logical() Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective. p integer(1) Hausdorff distance parameter (default: 1L).","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/igd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Inverted Generational Distance (IGD and IGD+) and Averaged Hausdorff Distance — igd","text":"numeric(1) single numerical value.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/igd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Inverted Generational Distance (IGD and IGD+) and Averaged Hausdorff Distance — igd","text":"generational distance (GD) set \\(\\) defined distance point \\(\\\\) closest point \\(r\\) reference set \\(R\\), averaged size \\(\\). Formally, $$GD_p(,R) = \\left(\\frac{1}{||}\\sum_{\\}\\min_{r\\R} d(,r)^p\\right)^{\\frac{1}{p}} $$ distance implementation Euclidean distance: $$d(,r) = \\sqrt{\\sum_{k=1}^m (a_k - r_k)^2} $$ inverted generational distance (IGD) calculated \\(IGD_p(,R) = GD_p(R,)\\). modified inverted generational distanced (IGD+) proposed Ishibuchi et al. (2015)  ensure IGD+ weakly Pareto compliant, similarly epsilon_additive() epsilon_mult(). modifies distance measure : $$d^+(r,) = \\sqrt{\\sum_{k=1}^m (\\max\\{r_k - a_k, 0\\})^2}$$ average Hausdorff distance (\\(\\Delta_p\\)) proposed Schütze et al. (2012)  calculated : $$\\Delta_p(,R) = \\max\\{ IGD_p(,R), IGD_p(R,) \\}$$ IGDX (Zhou et al. 2009)  application IGD decision vectors instead objective vectors measure closeness diversity decision space. One can use functions igd() igd_plus() (recommended) directly, just passing decision vectors data. different formulations GD IGD metrics literature differ value \\(p\\), distance metric used whether term \\(||^{-1}\\) inside () outside exponent \\(1/p\\).  GD first proposed Van Veldhuizen Lamont (1998)  \\(p=2\\) term \\(||^{-1}\\) outside exponent. IGD seems mentioned first Coello Coello Reyes-Sierra (2004) , however, people also used name D-metric concept \\(p=1\\) later papers often used IGD/GD \\(p=1\\). Schütze et al. (2012)  proposed place term \\(||^{-1}\\) inside exponent, formulation shown .  significant effect GD less IGD given constant reference set. IGD+ also follows formulation.  refer Ishibuchi et al. (2015)  Bezerra et al. (2017)  detailed historical perspective comparison various variants. Following Ishibuchi et al. (2015) , always use \\(p=1\\) implementation IGD IGD+ (1) setting used recent works; (2) makes irrelevant whether term \\(||^{-1}\\) inside outside exponent \\(1/p\\); (3) meaning IGD becomes average Euclidean distance reference point nearest objective vector. also slightly faster compute. GD never used directly compare quality approximations Pareto front, weakly Pareto-compliant often contradicts Pareto optimality. IGD still popular due historical reasons, strongly recommend IGD+ instead IGD, IGD contradicts Pareto optimality cases (see examples ) whereas IGD+ weakly Pareto-compliant. average Hausdorff distance \\(\\Delta_p(,R)\\) also weakly Pareto-compliant, shown examples .","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/igd.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Inverted Generational Distance (IGD and IGD+) and Averaged Hausdorff Distance — igd","text":"Leonardo C. T. Bezerra, Manuel López-Ibáñez, Thomas Stützle (2017). “Empirical Assessment Properties Inverted Generational Distance Indicators Multi- Many-objective Optimization.” Heike Trautmann, Günter Rudolph, Kathrin Klamroth, Oliver Schütze, Margaret M. Wiecek, Yaochu Jin, Christian Grimme (eds.), Evolutionary Multi-criterion Optimization, EMO 2017, volume 10173 Lecture Notes Computer Science, 31–45. Springer International Publishing, Cham, Switzerland. doi:10.1007/978-3-319-54157-0_3 . Carlos . Coello Coello, Margarita Reyes-Sierra (2004). “Study Parallelization Coevolutionary Multi-objective Evolutionary Algorithm.” Raúl Monroy, Gustavo Arroyo-Figueroa, Luis Enrique Sucar, Humberto Sossa (eds.), Proceedings MICAI, volume 2972 Lecture Notes Artificial Intelligence, 688–697. Springer, Heidelberg, Germany. Hisao Ishibuchi, Hiroyuki Masuda, Yuki Tanigaki, Yusuke Nojima (2015). “Modified Distance Calculation Generational Distance Inverted Generational Distance.” António Gaspar-Cunha, Carlos Henggeler Antunes, Carlos . Coello Coello (eds.), Evolutionary Multi-criterion Optimization, EMO 2015 Part , volume 9018 Lecture Notes Computer Science, 110–125. Springer, Heidelberg, Germany. Oliver Schütze, X Esquivel, Lara, Carlos . Coello Coello (2012). “Using Averaged Hausdorff Distance Performance Measure Evolutionary Multiobjective Optimization.” IEEE Transactions Evolutionary Computation, 16(4), 504–522. doi:10.1109/TEVC.2011.2161872 . David . Van Veldhuizen, Gary B. Lamont (1998). “Evolutionary Computation Convergence Pareto Front.” John R. Koza (ed.), Late Breaking Papers Genetic Programming 1998 Conference, 221–228. Zhou, Qingfu Zhang, Yaochu Jin (2009). “Approximating set Pareto-optimal solutions decision objective spaces estimation distribution algorithm.” IEEE Transactions Evolutionary Computation, 13(5), 1167–1189. doi:10.1109/TEVC.2009.2021467 .","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/igd.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Inverted Generational Distance (IGD and IGD+) and Averaged Hausdorff Distance — igd","text":"Manuel López-Ibáñez","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/igd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Inverted Generational Distance (IGD and IGD+) and Averaged Hausdorff Distance — igd","text":"","code":"# Example 4 from Ishibuchi et al. (2015) ref <- matrix(c(10,0,6,1,2,2,1,6,0,10), ncol=2, byrow=TRUE) A <- matrix(c(4,2,3,3,2,4), ncol=2, byrow=TRUE) B <- matrix(c(8,2,4,4,2,8), ncol=2, byrow=TRUE) if (requireNamespace(\"graphics\", quietly = TRUE)) {    plot(ref, xlab=expression(f[1]), ylab=expression(f[2]),         panel.first=grid(nx=NULL), pch=23, bg=\"gray\", cex=1.5)    points(A, pch=1, cex=1.5)    points(B, pch=19, cex=1.5)    legend(\"topright\", legend=c(\"Reference\", \"A\", \"B\"), pch=c(23,1,19),           pt.bg=\"gray\", bg=\"white\", bty = \"n\", pt.cex=1.5, cex=1.2) }  cat(\"A is better than B in terms of Pareto optimality,\\n however, IGD(A)=\",     igd(A, ref), \"> IGD(B)=\", igd(B, ref),     \"and AvgHausdorff(A)=\", avg_hausdorff_dist(A, ref),     \"> AvgHausdorff(B)=\", avg_hausdorff_dist(B, ref),     \", which both contradict Pareto optimality.\\nBy contrast, IGD+(A)=\",     igd_plus(A, ref), \"< IGD+(B)=\", igd_plus(B, ref), \", which is correct.\\n\") #> A is better than B in terms of Pareto optimality, #>  however, IGD(A)= 3.707092 > IGD(B)= 2.591483 and AvgHausdorff(A)= 3.707092 > AvgHausdorff(B)= 2.591483 , which both contradict Pareto optimality. #> By contrast, IGD+(A)= 1.482843 < IGD+(B)= 2.260113 , which is correct. # A less trivial example. extdata_path <- system.file(package=\"moocore\",\"extdata\") path.A1 <- file.path(extdata_path, \"ALG_1_dat.xz\") path.A2 <- file.path(extdata_path, \"ALG_2_dat.xz\") A1 <- read_datasets(path.A1)[,1:2] A2 <- read_datasets(path.A2)[,1:2] ref <- filter_dominated(rbind(A1, A2)) igd(A1, ref) #> [1] 91888189 igd(A2, ref) #> [1] 11351992  # IGD+ (Pareto compliant) igd_plus(A1, ref) #> [1] 82695357 igd_plus(A2, ref) #> [1] 10698269  # Average Haussdorff distance avg_hausdorff_dist(A1, ref) #> [1] 268547627 avg_hausdorff_dist(A2, ref) #> [1] 352613092"},{"path":"https://multi-objective.github.io/moocore/r/reference/largest_eafdiff.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify largest EAF differences — largest_eafdiff","title":"Identify largest EAF differences — largest_eafdiff","text":"Given list datasets, return indexes pair largest EAF differences according method proposed Diaz López-Ibáñez (2021) .","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/largest_eafdiff.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify largest EAF differences — largest_eafdiff","text":"","code":"largest_eafdiff(x, maximise = FALSE, intervals = 5L, reference, ideal = NULL)"},{"path":"https://multi-objective.github.io/moocore/r/reference/largest_eafdiff.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify largest EAF differences — largest_eafdiff","text":"x list() list matrices data frames least 3 columns (last column indicates set). maximise logical() Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective. intervals integer(1) absolute range differences \\([0, 1]\\) partitioned number intervals provided. reference numeric() Reference point vector numerical values. ideal numeric() Ideal point vector numerical values.  NULL, calculated minimum (maximum maximising objective) objective input data.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/largest_eafdiff.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify largest EAF differences — largest_eafdiff","text":"list() list two components pair value.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/largest_eafdiff.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Identify largest EAF differences — largest_eafdiff","text":"Juan Esteban Diaz, Manuel López-Ibáñez (2021). “Incorporating Decision-Maker's Preferences Automatic Configuration Bi-Objective Optimisation Algorithms.” European Journal Operational Research, 289(3), 1209–1222. doi:10.1016/j.ejor.2020.07.059 .","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/largest_eafdiff.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify largest EAF differences — largest_eafdiff","text":"","code":"# FIXME: This example is too large, we need a smaller one. data(tpls50x20_1_MWT) nadir <- apply(tpls50x20_1_MWT[,2:3], 2L, max) x <- largest_eafdiff(split.data.frame(tpls50x20_1_MWT[,2:4], tpls50x20_1_MWT[, 1L]),                      reference = nadir) str(x) #> List of 2 #>  $ pair : int [1:2] 3 6 #>  $ value: num 777017"},{"path":"https://multi-objective.github.io/moocore/r/reference/moocore-package.html","id":null,"dir":"Reference","previous_headings":"","what":"moocore: Core Mathematical Functions for Multi-Objective Optimization — moocore-package","title":"moocore: Core Mathematical Functions for Multi-Objective Optimization — moocore-package","text":"Fast implementations mathematical operations performance metrics multi-objective optimization, including filtering ranking dominated vectors according Pareto optimality, hypervolume metric, C.M. Fonseca, L. Paquete, M. López-Ibáñez (2006) doi:10.1109/CEC.2006.1688440 , epsilon indicator, inverted generational distance, computation empirical attainment function, V.G. da Fonseca, C.M. Fonseca, .O. Hall (2001) doi:10.1007/3-540-44719-9_15 , Vorob'ev threshold, expectation deviation, M. Binois, D. Ginsbourger, O. Roustant (2015) doi:10.1016/j.ejor.2014.07.032 , among others.","code":""},{"path":[]},{"path":"https://multi-objective.github.io/moocore/r/reference/moocore-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"moocore: Core Mathematical Functions for Multi-Objective Optimization — moocore-package","text":"Maintainer: Manuel López-Ibáñez manuel.lopez-ibanez@manchester.ac.uk (ORCID) contributors: Carlos Fonseca [contributor] Luís Paquete [contributor] Andreia P. Guerreiro [contributor] Mickaël Binois [contributor] Michael H. Buselli (AVL-tree library) [copyright holder] Wessel Dankers (AVL-tree library) [copyright holder] NumPy Developers (RNG ziggurat constants) [copyright holder] Jean-Sebastien Roy (mt19937 library) [copyright holder] Makoto Matsumoto (mt19937 library) [copyright holder] Takuji Nishimura (mt19937 library) [copyright holder]","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/nondominated.html","id":null,"dir":"Reference","previous_headings":"","what":"Identify, remove and rank dominated points according to Pareto optimality — is_nondominated","title":"Identify, remove and rank dominated points according to Pareto optimality — is_nondominated","text":"Identify nondominated points is_nondominated() remove dominated ones filter_dominated(). any_dominated() quickly detects set contains dominated point. pareto_rank() ranks points according Pareto-optimality, also called nondominated sorting (Deb et al. 2002) .","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/nondominated.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Identify, remove and rank dominated points according to Pareto optimality — is_nondominated","text":"","code":"is_nondominated(x, maximise = FALSE, keep_weakly = FALSE)  filter_dominated(x, maximise = FALSE, keep_weakly = FALSE)  any_dominated(x, maximise = FALSE, keep_weakly = FALSE)  pareto_rank(x, maximise = FALSE)"},{"path":"https://multi-objective.github.io/moocore/r/reference/nondominated.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Identify, remove and rank dominated points according to Pareto optimality — is_nondominated","text":"x matrix()|data.frame() Matrix data frame numerical values, row gives coordinates point. maximise logical() Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective. keep_weakly logical(1) FALSE, return FALSE duplicates nondominated points, except last one.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/nondominated.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Identify, remove and rank dominated points according to Pareto optimality — is_nondominated","text":"is_nondominated() returns logical vector length number rows data, TRUE means point dominated point. filter_dominated() returns matrix data.frame mutually nondominated points. any_dominated() returns TRUE x contains (weakly-)dominated points, FALSE otherwise. pareto_rank() returns integer vector length number rows data, value gives rank point.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/nondominated.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Identify, remove and rank dominated points according to Pareto optimality — is_nondominated","text":"Given \\(n\\) points dimension \\(m\\), current implementation uses well-known \\(O(n \\log n)\\) dimension-sweep algorithm (Kung et al. 1975)  \\(m \\leq 3\\) naive \\(O(m n^2)\\) algorithm \\(m \\geq 4\\).  best-known \\(O(n(\\log_2 n)^{m-2})\\) algorithm \\(m \\geq 4\\) (Kung et al. 1975)  implemented yet. pareto_rank() meant used like rank(), assigns ranks according Pareto dominance, rank 1 indicates solutions dominated solution input set. Duplicated points kept front. resulting ranking can used partition points list matrices, matrix representing nondominated front (see examples ) formally, given finite set points \\(X \\subset \\mathbb{R}^m\\), rank point \\(x \\X\\) defined : $$\\operatorname{rank}(x) = r \\iff x \\F^c_{r} \\land \\nexists y \\F^c_{r}, y \\prec x$$ \\(y \\prec x\\) means \\(y\\) dominates \\(x\\) according Pareto optimality, \\(F^c_r = X \\setminus \\bigcup_{=1}^{r-1} F_i\\) \\(F_r = \\{x \\X \\land \\operatorname{rank}(x) = r\\}\\).  sets \\(F_c\\), \\(c=1,\\dots,k\\), partition \\(X\\) \\(k\\) fronts, , mutually nondominated subsets \\(X\\). Let \\(m\\) number dimensions. \\(m=2\\), .e., ncol(data)=2, code uses \\(O(n \\log n)\\) algorithm Jensen (2003) .  \\(m=3\\), uses \\(O(k\\cdot n \\log n)\\) algorithm, \\(k\\) number fronts output.  higher dimensions, uses naive \\(O(k m n^2)\\) algorithm.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/nondominated.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Identify, remove and rank dominated points according to Pareto optimality — is_nondominated","text":"Kalyanmoy Deb, Pratap, S Agarwal, T Meyarivan (2002). “fast elitist multi-objective genetic algorithm: NSGA-II.” IEEE Transactions Evolutionary Computation, 6(2), 182–197. doi:10.1109/4235.996017 . M T Jensen (2003). “Reducing run-time complexity multiobjective EAs: NSGA-II algorithms.” IEEE Transactions Evolutionary Computation, 7(5), 503–515. H T Kung, F Luccio, F P Preparata (1975). “Finding Maxima Set Vectors.” Journal ACM, 22(4), 469–476. doi:10.1145/321906.321910 .","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/nondominated.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Identify, remove and rank dominated points according to Pareto optimality — is_nondominated","text":"Manuel López-Ibáñez","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/nondominated.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Identify, remove and rank dominated points according to Pareto optimality — is_nondominated","text":"","code":"S = matrix(c(1,1,0,1,1,0,1,0), ncol = 2, byrow = TRUE) is_nondominated(S) #> [1] FALSE  TRUE  TRUE FALSE is_nondominated(S, maximise = TRUE) #> [1]  TRUE FALSE FALSE FALSE filter_dominated(S) #>      [,1] [,2] #> [1,]    0    1 #> [2,]    1    0 filter_dominated(S, keep_weakly = TRUE) #>      [,1] [,2] #> [1,]    0    1 #> [2,]    1    0 #> [3,]    1    0 any_dominated(S) #> [1] TRUE any_dominated(S, keep_weakly = TRUE) #> [1] TRUE any_dominated(filter_dominated(S)) #> [1] FALSE  three_fronts = matrix(c(1, 2, 3,                         3, 1, 2,                         2, 3, 1,                         10, 20, 30,                         30, 10, 20,                         20, 30, 10,                         100, 200, 300,                         300, 100, 200,                         200, 300, 100), ncol=3, byrow=TRUE) pareto_rank(three_fronts) #> [1] 1 1 1 2 2 2 3 3 3  split.data.frame(three_fronts, pareto_rank(three_fronts)) #> $`1` #>      [,1] [,2] [,3] #> [1,]    1    2    3 #> [2,]    3    1    2 #> [3,]    2    3    1 #>  #> $`2` #>      [,1] [,2] [,3] #> [1,]   10   20   30 #> [2,]   30   10   20 #> [3,]   20   30   10 #>  #> $`3` #>      [,1] [,2] [,3] #> [1,]  100  200  300 #> [2,]  300  100  200 #> [3,]  200  300  100 #>  path_A1 <- file.path(system.file(package=\"moocore\"),\"extdata\",\"ALG_1_dat.xz\") set <- read_datasets(path_A1)[,1:2] is_nondom <- is_nondominated(set) cat(\"There are \", sum(is_nondom), \" nondominated points\\n\") #> There are  583  nondominated points  if (requireNamespace(\"graphics\", quietly = TRUE)) {    plot(set, col = \"blue\", type = \"p\", pch = 20)    ndset <- filter_dominated(set)    points(ndset[order(ndset[,1]),], col = \"red\", pch = 21) }   ranks <- pareto_rank(set) str(ranks) #>  int [1:23260] 13 24 20 22 22 5 23 5 16 20 ... if (requireNamespace(\"graphics\", quietly = TRUE)) {    colors <- colorRampPalette(c(\"red\",\"yellow\",\"springgreen\",\"royalblue\"))(max(ranks))    plot(set, col = colors[ranks], type = \"p\", pch = 20) }"},{"path":"https://multi-objective.github.io/moocore/r/reference/normalise.html","id":null,"dir":"Reference","previous_headings":"","what":"Normalise points — normalise","title":"Normalise points — normalise","text":"Normalise points per coordinate range, e.g., c(1,2), minimum value correspond 1 maximum 2. bounds given, used normalisation.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/normalise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Normalise points — normalise","text":"","code":"normalise(x, to_range = c(1, 2), lower = NA, upper = NA, maximise = FALSE)"},{"path":"https://multi-objective.github.io/moocore/r/reference/normalise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Normalise points — normalise","text":"x matrix()|data.frame() Matrix data frame numerical values, row gives coordinates point. to_range numerical(2) Normalise values range. objective maximised, normalised c(to_range[1], to_range[0]) instead. lower, upper numerical() Bounds values. NA, maximum minimum values coordinate used. maximise logical() Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/normalise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Normalise points — normalise","text":"matrix() numerical matrix","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/normalise.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Normalise points — normalise","text":"Manuel López-Ibáñez","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/normalise.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Normalise points — normalise","text":"","code":"data(SPEA2minstoptimeRichmond) # The second objective must be maximized head(SPEA2minstoptimeRichmond[, 1:2]) #>        V1    V2 #> 1 105.832   357 #> 2 108.187   911 #> 3 108.519  3960 #> 4 108.641  7560 #> 5 108.896 16532 #> 6 112.556 19957  head(normalise(SPEA2minstoptimeRichmond[, 1:2], maximise = c(FALSE, TRUE))) #>            V1       V2 #> [1,] 1.044174 2.000000 #> [2,] 1.059891 1.993561 #> [3,] 1.062107 1.958126 #> [4,] 1.062921 1.916286 #> [5,] 1.064623 1.812013 #> [6,] 1.089049 1.772207  head(normalise(SPEA2minstoptimeRichmond[, 1:2], to_range = c(0,1), maximise = c(FALSE, TRUE))) #>              V1        V2 #> [1,] 0.04417408 1.0000000 #> [2,] 0.05989095 0.9935614 #> [3,] 0.06210666 0.9581256 #> [4,] 0.06292087 0.9162860 #> [5,] 0.06462270 0.8120126 #> [6,] 0.08904891 0.7722069"},{"path":"https://multi-objective.github.io/moocore/r/reference/r2_exact.html","id":null,"dir":"Reference","previous_headings":"","what":"Exact R2 indicator — r2_exact","title":"Exact R2 indicator — r2_exact","text":"Computes exact R2 indicator respect given ideal/utopian reference point assuming minimization objectives.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/r2_exact.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Exact R2 indicator — r2_exact","text":"","code":"r2_exact(x, reference, maximise = FALSE)"},{"path":"https://multi-objective.github.io/moocore/r/reference/r2_exact.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Exact R2 indicator — r2_exact","text":"x matrix()|data.frame() Matrix data frame numerical values, row gives coordinates point. reference numeric() Reference (ideal) point vector numerical values. maximise logical() Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/r2_exact.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Exact R2 indicator — r2_exact","text":"numeric(1) single numerical value.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/r2_exact.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Exact R2 indicator — r2_exact","text":"unary R2 indicator quality indicator set \\(\\subset \\mathbb{R}^m\\) w.r.t. ideal utopian reference point \\(\\vec{r} \\\\mathbb{R}^m\\).  originally proposed Hansen Jaszkiewicz (1998)  defined expected Tchebycheff utility uniform distribution weight vectors (w.l.o.g. assuming minimization): $$R2() := \\int_{w \\W} \\min_{\\} \\left\\{ \\max_{=1,\\dots,m} w_i (a_i - r_i) \\right\\} \\, dw,$$ \\(W\\) denotes uniform distribution across weights: $$W = \\{w \\\\mathbb{R}^m \\mid w_i \\geq 0, \\sum_{=1}^m w_i = 1\\}.$$ R2 indicator minimized optimal value 0 \\(\\vec{r} \\\\). exact R2 indicator strongly Pareto-compliant, .e., compatible Pareto-optimality: $$\\forall , B \\subset \\mathbb{R}^m: \\prec B \\Rightarrow R2() < R2(B).$$ Given ideal utopian reference point, available scenarios, non-dominated solutions always contribute value exact R2 indicator.  However, scale-dependent care taken objectives contribute approximately equally indicator, e.g., normalizing Pareto front unit hypercube. current implementation exclusively supports bi-objective solution sets runs \\(O(n \\log n)\\) following Schäpermeier Kerschke (2025) .","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/r2_exact.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Exact R2 indicator — r2_exact","text":"Michael Pilegaard Hansen, Andrzej Jaszkiewicz (1998). “Evaluating quality approximations non-dominated set.” Technical Report IMM-REP-1998-7, Institute Mathematical Modelling, Technical University Denmark, Lyngby, Denmark. Lennart Schäpermeier, Pascal Kerschke (2025). “R2 v2: Pareto-compliant R2 Indicator Better Benchmarking Bi-objective Optimization.” Evolutionary Computation, 1–17. doi:10.1162/evco..366 .","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/r2_exact.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Exact R2 indicator — r2_exact","text":"","code":"dat <- matrix(c(5, 5, 4, 6, 2, 7, 7, 4), ncol = 2, byrow = TRUE) r2_exact(dat, reference = c(0, 0)) #> [1] 2.594192  # This function assumes minimisation by default. We can easily specify maximisation: r2_exact(dat, reference = c(10, 10), maximise = TRUE) #> [1] 2.519697  # Merge all the sets of a dataset by removing the set number column: extdata_path <- system.file(package=\"moocore\",\"extdata\") dat <- read_datasets(file.path(extdata_path, \"example1_dat\"))[, 1:2] nrow(dat) #> [1] 65  # Dominated points are ignored, so this: r2_exact(dat, reference = 0) #> [1] 3865393  # gives the same exact R2 value as this: dat <- filter_dominated(dat) nrow(dat) #> [1] 9 r2_exact(dat, reference = 0) #> [1] 3865393"},{"path":"https://multi-objective.github.io/moocore/r/reference/rbind_datasets.html","id":null,"dir":"Reference","previous_headings":"","what":"Combine datasets x and y by row taking care of making all sets unique. — rbind_datasets","title":"Combine datasets x and y by row taking care of making all sets unique. — rbind_datasets","text":"Combine datasets x y row taking care making sets unique.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/rbind_datasets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Combine datasets x and y by row taking care of making all sets unique. — rbind_datasets","text":"","code":"rbind_datasets(x, y)"},{"path":"https://multi-objective.github.io/moocore/r/reference/rbind_datasets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Combine datasets x and y by row taking care of making all sets unique. — rbind_datasets","text":"x, y matrix|data.frame() dataset least three columns, last one set point. See also read_datasets().","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/rbind_datasets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Combine datasets x and y by row taking care of making all sets unique. — rbind_datasets","text":"matrix()|data.frame()` dataset.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/rbind_datasets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Combine datasets x and y by row taking care of making all sets unique. — rbind_datasets","text":"","code":"x <- data.frame(f1 = 5:10, f2 = 10:5, set = 1:6) y <- data.frame(f1 = 15:20, f2 = 20:15, set = 1:6) rbind_datasets(x,y) #>    f1 f2 set #> 1   5 10   1 #> 2   6  9   2 #> 3   7  8   3 #> 4   8  7   4 #> 5   9  6   5 #> 6  10  5   6 #> 7  15 20   7 #> 8  16 19   8 #> 9  17 18   9 #> 10 18 17  10 #> 11 19 16  11 #> 12 20 15  12"},{"path":"https://multi-objective.github.io/moocore/r/reference/read_datasets.html","id":null,"dir":"Reference","previous_headings":"","what":"Read several data sets — read_datasets","title":"Read several data sets — read_datasets","text":"Reads text file table format creates matrix . file may contain several sets, separated empty lines. Lines starting '#' considered comments treated empty lines. function adds additional column set indicate set row belongs.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/read_datasets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read several data sets — read_datasets","text":"","code":"read_datasets(file, col_names, text)"},{"path":"https://multi-objective.github.io/moocore/r/reference/read_datasets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read several data sets — read_datasets","text":"file character() Filename contains data.  row table appears one line file.  contain absolute path, file name relative current working directory, base::getwd().  Tilde-expansion performed supported.  Files compressed xz supported. col_names character() Vector optional names variables.  default use \"V\" followed column number. text character() file supplied , data read value text via text connection. Notice literal string can used include (small) data sets within R code.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/read_datasets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read several data sets — read_datasets","text":"matrix() numerical matrix data file. extra column set added indicate set row belongs.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/read_datasets.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Read several data sets — read_datasets","text":"several examples data sets system.file(package=\"moocore\",\"extdata\").","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/read_datasets.html","id":"warning","dir":"Reference","previous_headings":"","what":"Warning","title":"Read several data sets — read_datasets","text":"known limitation input file must use newline characters native host system, otherwise , possibly silently, misinterpreted. GNU/Linux program dos2unix may used fix newline characters.","code":""},{"path":[]},{"path":"https://multi-objective.github.io/moocore/r/reference/read_datasets.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Read several data sets — read_datasets","text":"Manuel López-Ibáñez","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/read_datasets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Read several data sets — read_datasets","text":"","code":"extdata_path <- system.file(package=\"moocore\",\"extdata\") A1 <- read_datasets(file.path(extdata_path,\"ALG_1_dat.xz\")) str(A1) #>  num [1:23260, 1:3] 1.23e+10 1.11e+10 1.18e+10 1.13e+10 9.80e+09 ... #>  - attr(*, \"dimnames\")=List of 2 #>   ..$ : NULL #>   ..$ : chr [1:3] \"V1\" \"V2\" \"set\"  read_datasets(text=\"1 2\\n3 4\\n\\n5 6\\n7 8\\n\", col_names=c(\"obj1\", \"obj2\")) #>      obj1 obj2 set #> [1,]    1    2   1 #> [2,]    3    4   1 #> [3,]    5    6   2 #> [4,]    7    8   2"},{"path":"https://multi-objective.github.io/moocore/r/reference/tpls50x20_1_MWT.html","id":null,"dir":"Reference","previous_headings":"","what":"Various strategies of Two-Phase Local Search applied to the Permutation Flowshop Problem with Makespan and Weighted Tardiness objectives. — tpls50x20_1_MWT","title":"Various strategies of Two-Phase Local Search applied to the Permutation Flowshop Problem with Makespan and Weighted Tardiness objectives. — tpls50x20_1_MWT","text":"Various strategies Two-Phase Local Search applied Permutation Flowshop Problem Makespan Weighted Tardiness objectives.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/tpls50x20_1_MWT.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Various strategies of Two-Phase Local Search applied to the Permutation Flowshop Problem with Makespan and Weighted Tardiness objectives. — tpls50x20_1_MWT","text":"","code":"tpls50x20_1_MWT"},{"path":"https://multi-objective.github.io/moocore/r/reference/tpls50x20_1_MWT.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Various strategies of Two-Phase Local Search applied to the Permutation Flowshop Problem with Makespan and Weighted Tardiness objectives. — tpls50x20_1_MWT","text":"data frame 1511 observations 4 variables: algorithm TPLS search strategy Makespan first objective values. WeightedTardiness second objective values. run index run.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/tpls50x20_1_MWT.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Various strategies of Two-Phase Local Search applied to the Permutation Flowshop Problem with Makespan and Weighted Tardiness objectives. — tpls50x20_1_MWT","text":"Jérémie Dubois-Lacoste, Manuel López-Ibáñez, Thomas Stützle (2011). “Improving Anytime Behavior Two-Phase Local Search.” Annals Mathematics Artificial Intelligence, 61(2), 125–154. doi:10.1007/s10472-011-9235-0 .","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/tpls50x20_1_MWT.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Various strategies of Two-Phase Local Search applied to the Permutation Flowshop Problem with Makespan and Weighted Tardiness objectives. — tpls50x20_1_MWT","text":"","code":"data(tpls50x20_1_MWT) str(tpls50x20_1_MWT) #> 'data.frame':\t1511 obs. of  4 variables: #>  $ algorithm        : chr  \"1to2\" \"1to2\" \"1to2\" \"1to2\" ... #>  $ Makespan         : num  4280 4238 4137 4024 4014 ... #>  $ WeightedTardiness: num  10231 10999 11737 14871 17825 ... #>  $ run              : num  1 1 1 1 1 1 1 1 1 1 ..."},{"path":"https://multi-objective.github.io/moocore/r/reference/transform_maximise.html","id":null,"dir":"Reference","previous_headings":"","what":"Transform matrix according to maximise parameter — transform_maximise","title":"Transform matrix according to maximise parameter — transform_maximise","text":"Transform matrix according maximise parameter","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/transform_maximise.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Transform matrix according to maximise parameter — transform_maximise","text":"","code":"transform_maximise(x, maximise)"},{"path":"https://multi-objective.github.io/moocore/r/reference/transform_maximise.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Transform matrix according to maximise parameter — transform_maximise","text":"x matrix()|data.frame() Matrix data frame numerical values, row gives coordinates point. maximise logical() Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/transform_maximise.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Transform matrix according to maximise parameter — transform_maximise","text":"x transformed every column maximise TRUE multiplied -1.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/transform_maximise.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Transform matrix according to maximise parameter — transform_maximise","text":"","code":"x <- data.frame(f1=1:10, f2=101:110) rownames(x) <- letters[1:10] transform_maximise(x, maximise=c(FALSE,TRUE)) #>   f1   f2 #> a  1 -101 #> b  2 -102 #> c  3 -103 #> d  4 -104 #> e  5 -105 #> f  6 -106 #> g  7 -107 #> h  8 -108 #> i  9 -109 #> j 10 -110 transform_maximise(x, maximise=TRUE) #>    f1   f2 #> a  -1 -101 #> b  -2 -102 #> c  -3 -103 #> d  -4 -104 #> e  -5 -105 #> f  -6 -106 #> g  -7 -107 #> h  -8 -108 #> i  -9 -109 #> j -10 -110 x <- as.matrix(x) transform_maximise(x, maximise=c(FALSE,TRUE)) #>   f1   f2 #> a  1 -101 #> b  2 -102 #> c  3 -103 #> d  4 -104 #> e  5 -105 #> f  6 -106 #> g  7 -107 #> h  8 -108 #> i  9 -109 #> j 10 -110 transform_maximise(x, maximise=TRUE) #>    f1   f2 #> a  -1 -101 #> b  -2 -102 #> c  -3 -103 #> d  -4 -104 #> e  -5 -105 #> f  -6 -106 #> g  -7 -107 #> h  -8 -108 #> i  -9 -109 #> j -10 -110"},{"path":"https://multi-objective.github.io/moocore/r/reference/whv_hype.html","id":null,"dir":"Reference","previous_headings":"","what":"Approximation of the (weighted) hypervolume by Monte-Carlo sampling (2D only) — whv_hype","title":"Approximation of the (weighted) hypervolume by Monte-Carlo sampling (2D only) — whv_hype","text":"Return estimation hypervolume space dominated input data following procedure described Auger et al. (2009) . weight distribution describing user preferences may specified.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/whv_hype.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Approximation of the (weighted) hypervolume by Monte-Carlo sampling (2D only) — whv_hype","text":"","code":"whv_hype(   x,   reference,   ideal,   maximise = FALSE,   nsamples = 100000L,   seed = NULL,   dist = \"uniform\",   mu = NULL )"},{"path":"https://multi-objective.github.io/moocore/r/reference/whv_hype.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Approximation of the (weighted) hypervolume by Monte-Carlo sampling (2D only) — whv_hype","text":"x matrix()|data.frame() Matrix data frame numerical values, row gives coordinates point. reference numeric() Reference point vector numerical values. ideal numeric() Ideal point vector numerical values. maximise logical() Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective. nsamples integer(1) Number samples Monte-Carlo sampling. seed integer(1) Random seed. dist character(1) Weight distribution type. See Details. mu numeric() Parameter weight distribution. See Details.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/whv_hype.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Approximation of the (weighted) hypervolume by Monte-Carlo sampling (2D only) — whv_hype","text":"single numerical value.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/whv_hype.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Approximation of the (weighted) hypervolume by Monte-Carlo sampling (2D only) — whv_hype","text":"current implementation supports 2 objectives. weight distribution  (Auger et al. 2009)  can provided via dist argument. ones currently supported : \"uniform\" corresponds default hypervolume (unweighted). \"point\" describes goal objective space, parameter mu gives coordinates goal. resulting weight distribution multivariate normal distribution centred goal. \"exponential\" describes exponential distribution rate parameter 1/mu, .e., \\(\\lambda = \\frac{1}{\\mu}\\).","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/whv_hype.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Approximation of the (weighted) hypervolume by Monte-Carlo sampling (2D only) — whv_hype","text":"Anne Auger, Johannes Bader, Dimo Brockhoff, Eckart Zitzler (2009). “Articulating User Preferences Many-Objective Problems Sampling Weighted Hypervolume.” Franz Rothlauf (ed.), Proceedings  Genetic Evolutionary Computation Conference, GECCO 2009, 555–562. ACM Press, New York, NY.","code":""},{"path":[]},{"path":"https://multi-objective.github.io/moocore/r/reference/whv_hype.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Approximation of the (weighted) hypervolume by Monte-Carlo sampling (2D only) — whv_hype","text":"","code":"whv_hype(matrix(2, ncol=2), reference = 4, ideal = 1, seed = 42) #> [1] 3.99807 whv_hype(matrix(c(3,1), ncol=2), reference = 4, ideal = 1, seed = 42) #> [1] 3.00555 whv_hype(matrix(2, ncol=2), reference = 4, ideal = 1, seed = 42,          dist = \"exponential\", mu=0.2) #> [1] 1.14624 whv_hype(matrix(c(3,1), ncol=2), reference = 4, ideal = 1, seed = 42,          dist = \"exponential\", mu=0.2) #> [1] 1.66815 whv_hype(matrix(2, ncol=2), reference = 4, ideal = 1, seed = 42,          dist = \"point\", mu=c(2.9,0.9)) #> [1] 0.64485 whv_hype(matrix(c(3,1), ncol=2), reference = 4, ideal = 1, seed = 42,          dist = \"point\", mu=c(2.9,0.9)) #> [1] 4.03632"},{"path":"https://multi-objective.github.io/moocore/r/reference/whv_rect.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute (total) weighted hypervolume given a set of rectangles — whv_rect","title":"Compute (total) weighted hypervolume given a set of rectangles — whv_rect","text":"Calculates hypervolume weighted set rectangles (zero weight outside rectangles). function total_whv_rect() calculates total weighted hypervolume hypervolume() + scalefactor * abs(prod(reference - ideal)) * whv_rect(). details computation given Diaz López-Ibáñez (2021) .","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/whv_rect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute (total) weighted hypervolume given a set of rectangles — whv_rect","text":"","code":"whv_rect(x, rectangles, reference, maximise = FALSE)  total_whv_rect(   x,   rectangles,   reference,   maximise = FALSE,   ideal = NULL,   scalefactor = 0.1 )"},{"path":"https://multi-objective.github.io/moocore/r/reference/whv_rect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute (total) weighted hypervolume given a set of rectangles — whv_rect","text":"x matrix()|data.frame() Matrix data frame numerical values, row gives coordinates point. rectangles matrix() Weighted rectangles bias computation hypervolume. Maybe generated eafdiff() rectangles=TRUE choose_eafdiff(). reference numeric() Reference point vector numerical values. maximise logical() Whether objectives must maximised instead minimised. Either single logical value applies objectives vector logical values, one value per objective. ideal numeric() Ideal point vector numerical values.  NULL, calculated minimum (maximum maximising objective) objective input data. scalefactor numeric(1) Real value within \\((0,1]\\) scales overall weight differences. parameter psi (\\(\\psi\\)) Diaz López-Ibáñez (2021) .","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/whv_rect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute (total) weighted hypervolume given a set of rectangles — whv_rect","text":"numeric(1) single numerical value.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/whv_rect.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute (total) weighted hypervolume given a set of rectangles — whv_rect","text":"TODO","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/whv_rect.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Compute (total) weighted hypervolume given a set of rectangles — whv_rect","text":"Juan Esteban Diaz, Manuel López-Ibáñez (2021). “Incorporating Decision-Maker's Preferences Automatic Configuration Bi-Objective Optimisation Algorithms.” European Journal Operational Research, 289(3), 1209–1222. doi:10.1016/j.ejor.2020.07.059 .","code":""},{"path":[]},{"path":"https://multi-objective.github.io/moocore/r/reference/whv_rect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute (total) weighted hypervolume given a set of rectangles — whv_rect","text":"","code":"rectangles <- as.matrix(read.table(header=FALSE, text='  1.0  3.0  2.0  Inf    1  2.0  3.5  2.5  Inf    2  2.0  3.0  3.0  3.5    3 ')) whv_rect (matrix(2, ncol=2), rectangles, reference = 6) #> [1] 4 whv_rect (matrix(c(2, 1), ncol=2), rectangles, reference = 6) #> [1] 4 whv_rect (matrix(c(1, 2), ncol=2), rectangles, reference = 6) #> [1] 7  total_whv_rect (matrix(2, ncol=2), rectangles, reference = 6, ideal = c(1,1)) #> [1] 26 total_whv_rect (matrix(c(2, 1), ncol=2), rectangles, reference = 6, ideal = c(1,1)) #> [1] 30 total_whv_rect (matrix(c(1, 2), ncol=2), rectangles, reference = 6, ideal = c(1,1)) #> [1] 37.5"},{"path":"https://multi-objective.github.io/moocore/r/reference/write_datasets.html","id":null,"dir":"Reference","previous_headings":"","what":"Write data sets — write_datasets","title":"Write data sets — write_datasets","text":"Write data sets file format read_datasets().","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/write_datasets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Write data sets — write_datasets","text":"","code":"write_datasets(x, file = \"\")"},{"path":"https://multi-objective.github.io/moocore/r/reference/write_datasets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Write data sets — write_datasets","text":"x matrix|data.frame() Dataset least three columns, last one set point. See also read_datasets(). file Either character string naming file connection open writing. \"\" indicates output console.","code":""},{"path":"https://multi-objective.github.io/moocore/r/reference/write_datasets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Write data sets — write_datasets","text":"return value, called side effects","code":""},{"path":[]},{"path":"https://multi-objective.github.io/moocore/r/reference/write_datasets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Write data sets — write_datasets","text":"","code":"x <- read_datasets(text=\"1 2\\n3 4\\n\\n5 6\\n7 8\\n\", col_names=c(\"obj1\", \"obj2\")) write_datasets(x) #> # obj1\tobj2  #> 1 2 #> 3 4 #>  #> 5 6 #> 7 8"},{"path":"https://multi-objective.github.io/moocore/r/news/index.html","id":"moocore-020900","dir":"Changelog","previous_headings":"","what":"moocore 0.2.0.900","title":"moocore 0.2.0.900","text":"r2_exact() implements exact computation R2 indicator bi-objective solution sets. hypervolume() significantly faster four dimensions (Andreia P. Guerreiro). hypervolume() now handles 1D inputs provides clear error 0D inputs (#58).","code":""},{"path":"https://multi-objective.github.io/moocore/r/news/index.html","id":"moocore-020","dir":"Changelog","previous_headings":"","what":"moocore 0.2.0","title":"moocore 0.2.0","text":"CRAN release: 2026-01-11 pareto_rank() faster 3D. HV3D+ slightly faster repeated coordinates (#41). igd(), igd_plus(), avg_hausdorff_dist() faster. Fix wrong values returned epsilon_mult() mixing minimization maximization. Fix documentation epsilon_additive() (@leandrolanzieri) hypervolume() uses inclusion-exclusion algorithm small inputs 15 points, significantly faster.","code":""},{"path":"https://multi-objective.github.io/moocore/r/news/index.html","id":"moocore-0110","dir":"Changelog","previous_headings":"","what":"moocore 0.1.10","title":"moocore 0.1.10","text":"CRAN release: 2025-11-25 mooocore now requires R >= 4.1. is_nondominated(): Fix wrong assert (#38).","code":""},{"path":"https://multi-objective.github.io/moocore/r/news/index.html","id":"moocore-019","dir":"Changelog","previous_headings":"","what":"moocore 0.1.9","title":"moocore 0.1.9","text":"CRAN release: 2025-11-01 hv_contributions() ignores dominated points default. Set ignore_dominated=FALSE restore previous behavior. 3D case uses HVC3D algorithm. New function any_dominated(). New function generate_ndset() generate random nondominated sets different shapes. New article: “Benchmarks” New article: “Computing Multi-Objective Quality Metrics” New article: “Sampling Random Nondominated Sets” is_nondominated(), any_dominated() pareto_rank() now handle single-objective inputs correctly (#27) (#29). is_nondominated() filter_dominated() faster dimensions larger 3. is_nondominated() filter_dominated() now stable 2D 3D keep_weakly=FALSE, , first duplicated points marked nondominated.","code":""},{"path":"https://multi-objective.github.io/moocore/r/news/index.html","id":"moocore-018","dir":"Changelog","previous_headings":"","what":"moocore 0.1.8","title":"moocore 0.1.8","text":"CRAN release: 2025-07-15 Document EAF Vorob’ev expectation deviation detail. New function hv_approx(). Function hv_contributions() much faster 2D inputs. New article “Approximating hypervolume”. New datasets DTLZLinearShape.8d.front.60pts.10 ran.10pts.9d.10.","code":""},{"path":"https://multi-objective.github.io/moocore/r/news/index.html","id":"moocore-017","dir":"Changelog","previous_headings":"","what":"moocore 0.1.7","title":"moocore 0.1.7","text":"CRAN release: 2025-06-05 hypervolume() now uses HV3D+ algorithm 3D case HV4D+ algorithm 4D case. dimensions larger 4, recursive algorithm uses HV4D+ base case, significantly faster. read_datasets() significantly faster large files. is_nondominated() filter_dominated() faster 3D inputs.","code":""},{"path":"https://multi-objective.github.io/moocore/r/news/index.html","id":"moocore-016","dir":"Changelog","previous_headings":"","what":"moocore 0.1.6","title":"moocore 0.1.6","text":"CRAN release: 2025-05-13 Fix parallel build CRAN.","code":""},{"path":"https://multi-objective.github.io/moocore/r/news/index.html","id":"moocore-015","dir":"Changelog","previous_headings":"","what":"moocore 0.1.5","title":"moocore 0.1.5","text":"CRAN release: 2025-05-11 Rename vorobT() vorobDev() vorob_t() vorob_dev() consistent function names.","code":""},{"path":"https://multi-objective.github.io/moocore/r/news/index.html","id":"moocore-012","dir":"Changelog","previous_headings":"","what":"moocore 0.1.2","title":"moocore 0.1.2","text":"CRAN release: 2024-09-18 Fix warnings problems show CRAN.","code":""},{"path":"https://multi-objective.github.io/moocore/r/news/index.html","id":"moocore-011","dir":"Changelog","previous_headings":"","what":"moocore 0.1.1","title":"moocore 0.1.1","text":"Fix problems show CRAN.","code":""},{"path":"https://multi-objective.github.io/moocore/r/news/index.html","id":"moocore-010","dir":"Changelog","previous_headings":"","what":"moocore 0.1.0","title":"moocore 0.1.0","text":"CRAN release: 2024-07-28 Initial version uploaded CRAN.","code":""}]
